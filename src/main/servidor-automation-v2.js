const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');
const { login } = require('../login.js');
const { loadConfig } = require('../util.js');
const ParallelOJProcessor = require('./parallel-oj-processor.js');
const TimeoutManager = require('../utils/timeouts.js');
const ContextualDelayManager = require('./contextual-delay-manager.js');
const DOMCacheManager = require('./dom-cache-manager.js');
const SmartRetryManager = require('./smart-retry-manager.js');
const NavigationOptimizer = require('./navigation-optimizer.js');
const PerformanceMonitor = require('./performance-monitor.js');

/**
 * Automa√ß√£o moderna para vincula√ß√£o de OJs a servidores
 * Baseada no documento automacao.md com melhorias implementadas
 */
class ServidorAutomationV2 {
  constructor() {
    this.isRunning = false;
    this.currentProgress = 0;
    this.totalOrgaos = 0;
    this.mainWindow = null;
    this.browser = null;
    this.page = null;
    this.config = null;
    this.results = [];
    this.ojCache = new Set(); // Cache para OJs j√° cadastrados
    this.isProduction = process.env.NODE_ENV === 'production';
    this.timeoutManager = new TimeoutManager();
    this.delayManager = new ContextualDelayManager(this.timeoutManager);
    this.retryManager = new SmartRetryManager(this.timeoutManager);
    this.navigationOptimizer = new NavigationOptimizer(this.timeoutManager, this.retryManager);
    this.performanceMonitor = new PerformanceMonitor();
    this.domCache = null;
    this.parallelProcessor = null;
  }

  setMainWindow(window) {
    this.mainWindow = window;
  }

  /**
   * Inicializa o cache DOM quando a p√°gina estiver dispon√≠vel
   */
  initializeDOMCache() {
    if (this.page && !this.domCache) {
      this.domCache = new DOMCacheManager(this.page, this.timeoutManager);
      console.log('‚úÖ Cache DOM inicializado');
    }
  }

  // Fun√ß√£o helper para delay contextual otimizado
  async delay(ms, context = 'default') {
    if (context === 'default') {
      // Manter compatibilidade com delays fixos existentes
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // Usar delay contextual adaptativo
    return await this.delayManager.smartDelay(context, { priority: 'normal' });
  }
  
  // Novo m√©todo para delay contextual com op√ß√µes
  async contextualDelay(context, options = {}) {
    return await this.delayManager.smartDelay(context, options);
  }

  // Normalizar nomes de √≥rg√£os julgadores para corrigir erros de digita√ß√£o
  normalizeOrgaoName(orgao) {
    return orgao
      .replace(/\s+/g, ' ')  // Normalizar espa√ßos m√∫ltiplos
      .replace(/doTrabalho/g, 'do Trabalho')  // Corrigir "doTrabalho" ‚Üí "do Trabalho"
      .replace(/daTrabalho/g, 'da Trabalho')  // Corrigir "daTrabalho" ‚Üí "da Trabalho"  
      .replace(/deTrabalho/g, 'de Trabalho')  // Corrigir "deTrabalho" ‚Üí "de Trabalho"
      .replace(/Trrabalho/g, 'Trabalho')  // Corrigir "Trrabalho" ‚Üí "Trabalho" (duplo R)
      .replace(/trrabalho/g, 'trabalho')  // Corrigir vers√£o min√∫scula
      .trim();
  }

  sendStatus(type, message, progress = null, subtitle = null, orgao = null) {
    try {
      if (this.mainWindow && !this.mainWindow.isDestroyed()) {
        this.mainWindow.webContents.send('automation-progress', {
          type,
          message,
          progress,
          subtitle,
          orgao,
          automationType: 'servidor-v2'
        });
      }
    } catch (error) {
      // Erro de IPC - n√£o √© cr√≠tico, apenas log
      console.warn('Erro ao enviar status IPC:', error.message);
    }
        
    try {
      console.log(`[${type.toUpperCase()}] ${message}${subtitle ? ` - ${subtitle}` : ''}${orgao ? ` (${orgao})` : ''}`);
    } catch (error) {
      // Em caso de erro at√© no console.log, usar process.stdout
      process.stdout.write(`[${type.toUpperCase()}] ${message}\n`);
    }
  }

  async startAutomation(config) {
    if (this.isRunning) {
      throw new Error('Automa√ß√£o j√° est√° em execu√ß√£o');
    }

    this.isRunning = true;
    this.config = config;
    this.currentProgress = 0;
    this.results = [];
    
    // Iniciar monitoramento de performance
    this.performanceMonitor.startMonitoring();

    try {
      // Suporte para processamento em lote de m√∫ltiplos servidores
      if (config.servidores && config.servidores.length > 0) {
        await this.processMultipleServidores(config);
      } else {
        // Modo compatibilidade - processar servidor √∫nico
        this.totalOrgaos = config.orgaos ? config.orgaos.length : 0;
        await this.processSingleServidor(config);
      }
            
      this.sendStatus('success', 'Automa√ß√£o conclu√≠da com sucesso!', 100, 'Processo finalizado');
            
    } catch (error) {
      console.error('Erro na automa√ß√£o:', error);
      this.sendStatus('error', `Erro na automa√ß√£o: ${error.message}`, this.currentProgress, 'Erro cr√≠tico');
      throw error;
    } finally {
      await this.cleanup();
      this.isRunning = false;
    }
  }

  async processMultipleServidores(config) {
    const servidores = config.servidores;
    this.totalOrgaos = servidores.reduce((total, servidor) => total + (servidor.orgaos ? servidor.orgaos.length : 0), 0);
    
    // Inicializar estrutura de relat√≥rio por servidor
    this.servidorResults = {};
    this.processedServidores = 0;
    this.successfulServidores = 0;
    this.failedServidores = 0;
    this.consecutiveErrors = 0;
    this.maxConsecutiveErrors = 3; // Parar ap√≥s 3 erros consecutivos
    
    this.sendStatus('info', `üöÄ AUTOMA√á√ÉO EM LOTE: ${servidores.length} servidores, ${this.totalOrgaos} OJs total`, 0, 'Iniciando processamento sequencial robusto');
    
    await this.initializeBrowser();
    await this.performLogin();
    
    // Processar cada servidor na mesma sess√£o com recupera√ß√£o robusta
    for (let i = 0; i < servidores.length; i++) {
      const servidor = servidores[i];
      const progressBase = (i / servidores.length) * 90;
      
      // Verificar limite de erros consecutivos
      if (this.consecutiveErrors >= this.maxConsecutiveErrors) {
        this.sendStatus('error', `üö® PARADA DE SEGURAN√áA: ${this.maxConsecutiveErrors} erros consecutivos detectados`, 90, 'Automa√ß√£o interrompida por seguran√ßa');
        break;
      }
      
      // Inicializar resultado do servidor
      this.servidorResults[servidor.cpf] = {
        nome: servidor.nome,
        cpf: servidor.cpf,
        perfil: servidor.perfil,
        totalOJs: servidor.orgaos ? servidor.orgaos.length : 0,
        ojsProcessados: 0,
        sucessos: 0,
        erros: 0,
        jaIncluidos: 0,
        detalhes: [],
        status: 'Processando',
        inicioProcessamento: new Date().toISOString(),
        fimProcessamento: null,
        tempoProcessamento: null,
        tentativas: 0,
        maxTentativas: 2
      };
      
      this.sendStatus('info', `üéØ [${i + 1}/${servidores.length}] ${servidor.nome}`, 
        progressBase, `CPF: ${servidor.cpf} | ${servidor.orgaos?.length || 0} OJs | Erros consecutivos: ${this.consecutiveErrors}`);
      
      const startTime = Date.now();
      let servidorProcessado = false;
      
      // Tentar processar servidor com retry autom√°tico
      for (let tentativa = 1; tentativa <= this.servidorResults[servidor.cpf].maxTentativas && !servidorProcessado; tentativa++) {
        this.servidorResults[servidor.cpf].tentativas = tentativa;
        
        try {
          this.sendStatus('info', `üîÑ [${i + 1}/${servidores.length}] Tentativa ${tentativa}/${this.servidorResults[servidor.cpf].maxTentativas} - ${servidor.nome}`, 
            progressBase, 'Preparando processamento...');
          
          console.log(`üéØ ===== INICIANDO PROCESSAMENTO DO SERVIDOR ${i + 1}: ${servidor.nome} =====`);
          
          // Garantir navegador ativo antes de processar
          console.log(`üîç [${i + 1}/${servidores.length}] Verificando navegador ativo...`);
          await this.ensureBrowserActive();
          
          // Garantir recupera√ß√£o completa antes de processar
          console.log(`üßπ [${i + 1}/${servidores.length}] Limpando estado...`);
          await this.ensureCleanState();
          
          // Configurar dados do servidor atual
          console.log(`‚öôÔ∏è [${i + 1}/${servidores.length}] Configurando dados do servidor...`);
          this.config.cpf = servidor.cpf;
          this.config.perfil = servidor.perfil;
          this.config.orgaos = servidor.orgaos || [];
          console.log(`üìã Servidor configurado: CPF=${servidor.cpf}, Perfil=${servidor.perfil}, OJs=${servidor.orgaos?.length || 0}`);
          
          // Debug detalhado do estado atual
          console.log('üîç [DEBUG] Estado do navegador:');
          const currentUrl = this.page.url();
          console.log(`   URL atual: ${currentUrl}`);
          const pageTitle = await this.page.title();
          console.log(`   T√≠tulo: ${pageTitle}`);
          console.log(`   Servidor ${i + 1}: ${servidor.nome} (${servidor.cpf})`);
          console.log(`   OJs a processar: ${JSON.stringify(servidor.orgaos?.slice(0,3) || [])}${servidor.orgaos?.length > 3 ? '...' : ''}`);
          
          // Navega√ß√£o robusta
          console.log(`üîó [${i + 1}/${servidores.length}] Navegando para pessoa...`);
          await this.navigateDirectlyToPerson(servidor.cpf);
          
          // Debug ap√≥s navega√ß√£o
          const urlAposNavegacao = this.page.url();
          console.log(`üîç [DEBUG] URL ap√≥s navega√ß√£o: ${urlAposNavegacao}`);
          console.log(`üîç [DEBUG] Navega√ß√£o para ${servidor.nome} (${servidor.cpf}) CONCLU√çDA`);
          
          console.log(`üìÇ [${i + 1}/${servidores.length}] Acessando aba servidor...`);
          await this.navigateToServerTab();
          
          // Debug ap√≥s acessar aba servidor
          const urlAposAbaServidor = this.page.url();
          console.log(`üîç [DEBUG] URL ap√≥s aba servidor: ${urlAposAbaServidor}`);
          console.log(`üîç [DEBUG] Aba servidor acessada para ${servidor.nome}`);
          
          // Processar OJs com monitoramento detalhado
          console.log(`üéØ [${i + 1}/${servidores.length}] Processando ${servidor.orgaos?.length || 0} OJs...`);
          console.log(`üîç [DEBUG] Iniciando processamento de OJs para ${servidor.nome}:`);
          for (let debugOJ = 0; debugOJ < Math.min(3, servidor.orgaos?.length || 0); debugOJ++) {
            console.log(`   OJ ${debugOJ + 1}: ${servidor.orgaos[debugOJ]}`);
          }
          
          await this.processOrgaosJulgadoresWithServerTracking(servidor);
          console.log(`‚úÖ [${i + 1}/${servidores.length}] Processamento de OJs conclu√≠do`);
          console.log(`üîç [DEBUG] Processamento de OJs FINALIZADO para ${servidor.nome}`);
          
          // Finalizar resultado do servidor
          console.log(`üìã [${i + 1}/${servidores.length}] Finalizando resultado do servidor...`);
          const serverResult = this.servidorResults[servidor.cpf];
          serverResult.status = 'Conclu√≠do';
          serverResult.fimProcessamento = new Date().toISOString();
          serverResult.tempoProcessamento = Date.now() - startTime;
          
          this.processedServidores++;
          this.successfulServidores++;
          this.consecutiveErrors = 0; // Reset contador de erros
          
          console.log(`üéâ [${i + 1}/${servidores.length}] Servidor ${servidor.nome} CONCLU√çDO com sucesso!`);
          
          this.sendStatus('success', `‚úÖ [${i + 1}/${servidores.length}] ${servidor.nome}: ${serverResult.sucessos} sucessos, ${serverResult.erros} erros`, 
            ((i + 1) / servidores.length) * 90, `Tempo: ${(serverResult.tempoProcessamento/1000).toFixed(1)}s`);
          
          servidorProcessado = true;
          
        } catch (error) {
          console.error(`‚ùå TENTATIVA ${tentativa} FALHOU - Servidor: ${servidor.nome} (${servidor.cpf})`);
          console.error(`   Erro: ${error.message}`);
          
          if (tentativa === this.servidorResults[servidor.cpf].maxTentativas) {
            // √öltima tentativa falhou
            const serverResult = this.servidorResults[servidor.cpf];
            serverResult.status = 'Erro';
            serverResult.fimProcessamento = new Date().toISOString();
            serverResult.tempoProcessamento = Date.now() - startTime;
            serverResult.erroGeral = error.message;
            
            this.processedServidores++;
            this.failedServidores++;
            this.consecutiveErrors++;
            
            this.sendStatus('error', `‚ùå [${i + 1}/${servidores.length}] ${servidor.nome}: ${error.message}`, 
              ((i + 1) / servidores.length) * 90, `FALHA ap√≥s ${this.servidorResults[servidor.cpf].maxTentativas} tentativas`);
            
            // Log detalhado do erro final
            console.error(`üí• FALHA FINAL - Servidor: ${servidor.nome} (${servidor.cpf})`);
            console.error(`   Erro: ${error.message}`);
            console.error(`   Stack: ${error.stack}`);
            console.error(`   Tentativas realizadas: ${tentativa}`);
          } else {
            // Ainda h√° tentativas, tentar recupera√ß√£o
            this.sendStatus('warning', `‚ö†Ô∏è [${i + 1}/${servidores.length}] Tentativa ${tentativa} falhou: ${error.message}`, 
              progressBase, 'Tentando recupera√ß√£o para pr√≥xima tentativa...');
          }
          
          // Tentar recupera√ß√£o robusta para pr√≥xima tentativa ou pr√≥ximo servidor
          await this.performRobustRecovery();
        }
      }
      
      // Pausa estabilizada entre servidores para garantir continuidade
      if (i < servidores.length - 1) {
        console.log(`üîÑ ===== TRANSI√á√ÉO: Servidor ${i + 1} ‚Üí Servidor ${i + 2} =====`);
        console.log(`‚è≥ Preparando para pr√≥ximo servidor (${servidores[i + 1].nome})...`);
        
        this.sendStatus('info', '‚è≥ Preparando para pr√≥ximo servidor...', 
          ((i + 1) / servidores.length) * 90, 'Estabilizando sistema');
        
        // Limpeza extra entre servidores
        try {
          console.log('üßπ Limpeza extra entre servidores...');
          
          // IMPORTANTE: Limpar cache de OJs entre servidores
          console.log(`üóëÔ∏è Limpando cache de OJs (${this.ojCache.size} OJs em cache)...`);
          this.ojCache.clear();
          console.log('‚úÖ Cache de OJs limpo - pr√≥ximo servidor processar√° todos os OJs');
          
          await this.closeAnyModals();
          await this.contextualDelay('stabilization', { priority: 'high' }); // Pausa maior para estabilidade
          console.log('‚úÖ Sistema estabilizado para pr√≥ximo servidor');
        } catch (transitionError) {
          console.log('‚ö†Ô∏è Erro na transi√ß√£o entre servidores:', transitionError.message);
          await this.contextualDelay('errorRecovery', { priority: 'high' }); // Pausa extra se houver erro
        }
      } else {
        console.log('üèÅ ===== √öLTIMO SERVIDOR PROCESSADO - FINALIZANDO =====');
      }
    }
    
    await this.generateMultiServerReport();
  }

  async processSingleServidor(config) {
    this.sendStatus('info', 'Iniciando automa√ß√£o moderna...', 0, 'Configurando ambiente');
            
    await this.initializeBrowser();
    await this.performLogin();
    await this.navigateDirectlyToPerson(config.cpf);
    await this.navigateToServerTab();
    await this.processOrgaosJulgadores();
    await this.generateReport();
  }

  async initializeBrowser() {
    this.sendStatus('info', 'Inicializando navegador...', 5, 'Configurando Playwright');
        
    const browserOptions = {
      headless: this.isProduction,
      slowMo: this.isProduction ? 0 : 50,
      timeout: 30000
    };

    // Em desenvolvimento, tentar conectar a Chrome existente
    if (!this.isProduction) {
      try {
        this.browser = await chromium.connectOverCDP('http://localhost:9222');
        const contexts = this.browser.contexts();
        if (contexts.length > 0 && contexts[0].pages().length > 0) {
          this.page = contexts[0].pages()[0];
        } else {
          const context = await this.browser.newContext();
          this.page = await context.newPage();
        }
        this.sendStatus('info', 'Conectado ao Chrome existente', 10, 'Modo desenvolvimento');
      } catch (error) {
        console.log('N√£o foi poss√≠vel conectar ao Chrome existente, iniciando novo navegador');
        this.browser = await chromium.launch(browserOptions);
        const context = await this.browser.newContext();
        this.page = await context.newPage();
      }
    } else {
      this.browser = await chromium.launch(browserOptions);
      const context = await this.browser.newContext();
      this.page = await context.newPage();
    }

    // Configurar User-Agent e cabe√ßalhos
    await this.page.setExtraHTTPHeaders({
      'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8',
      'Accept-Encoding': 'gzip, deflate, br',
      'Cache-Control': 'no-cache',
      'Pragma': 'no-cache',
      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    });

    // Interceptar falhas de rede e tentar novamente
    this.page.on('requestfailed', request => {
      console.log(`‚ö†Ô∏è Request failed: ${request.url()} - ${request.failure()?.errorText}`);
    });
        
    // Configurar timeouts mais generosos
    this.page.setDefaultTimeout(30000); // 30s para elementos
    
    // Inicializar cache DOM
    this.initializeDOMCache();
    this.page.setDefaultNavigationTimeout(60000); // 60s para navega√ß√£o

    // Capturar logs do console
    this.page.on('console', msg => {
      const logMessage = msg.text();
      if (logMessage.includes('ERROR') || logMessage.includes('WARN')) {
        console.log('Browser console:', logMessage);
      }
    });

    this.sendStatus('success', 'Navegador inicializado', 15, 'Pronto para automa√ß√£o');
  }

  async performLogin() {
    this.sendStatus('info', 'Realizando login...', 20, 'Autenticando no PJe');
        
    // Usar fun√ß√£o login() existente que j√° est√° otimizada
    try {
      await login(this.page);
      this.sendStatus('success', 'Login realizado com sucesso', 30, 'Autenticado');
    } catch (error) {
      console.log('‚ö†Ô∏è Erro no login:', error.message);
      throw new Error(`Falha no login: ${error.message}`);
    }
  }

  async navigateDirectlyToPerson(cpf) {
    const startTime = Date.now();
    this.performanceMonitor.recordNavigationStart('navigateDirectlyToPerson', `CPF: ${cpf}`);
    
    this.sendStatus('info', 'Navegando diretamente para pessoa...', 35, `CPF: ${cpf}`);
        
    const cpfFormatado = cpf; // Manter formata√ß√£o original
        
    // URL direta para a p√°gina da pessoa
    const directUrl = `https://pje.trt15.jus.br/pjekz/pessoa-fisica?pagina=1&tamanhoPagina=10&cpf=${encodeURIComponent(cpfFormatado)}&situacao=1`;
        
    console.log(`üîó Navegando para URL direta: ${directUrl}`);
    
    // IMPORTANTE: Fechar qualquer modal/overlay antes de navegar
    try {
      console.log('üßπ Limpando modais antes da navega√ß√£o...');
      await this.closeAnyModals();
      await this.contextualDelay('navigation', { priority: 'normal' });
    } catch (cleanError) {
      console.log('‚ö†Ô∏è Erro na limpeza inicial:', cleanError.message);
    }
        
    // M√∫ltiplas estrat√©gias de carregamento para otimizar velocidade
    const navigationStrategies = [
      { waitUntil: 'domcontentloaded', timeout: 15000, description: 'DOM carregado' },
      { waitUntil: 'load', timeout: 25000, description: 'P√°gina carregada' },
      { waitUntil: 'networkidle', timeout: 40000, description: 'Rede est√°vel' }
    ];
        
    let navigationSuccess = false;
    let lastError = null;
        
    for (const strategy of navigationStrategies) {
      try {
        this.sendStatus('info', `Tentando navega√ß√£o: ${strategy.description}`, 36, `Timeout: ${strategy.timeout/1000}s`);
                
        await this.navigationOptimizer.optimizedNavigate(this.page, directUrl);
                
        // Aguardar elementos cr√≠ticos aparecerem
        await Promise.race([
          this.page.waitForSelector('table', { timeout: 5000 }),
          this.page.waitForSelector('.datatable', { timeout: 5000 }),
          this.page.waitForSelector('[data-test-id]', { timeout: 5000 }),
          this.page.waitForTimeout(2000) // Fallback m√≠nimo
        ]);
        
        // IMPORTANTE: Verificar se n√£o h√° modais bloqueando ap√≥s navega√ß√£o
        console.log('üßπ Limpando modais ap√≥s navega√ß√£o...');
        await this.closeAnyModals();
        await this.contextualDelay('pageLoad', { priority: 'normal' });
                
        navigationSuccess = true;
        this.sendStatus('success', `Navega√ß√£o bem-sucedida com: ${strategy.description}`, 40, 'Pessoa encontrada');
        break;
                
      } catch (error) {
        console.warn(`‚ö†Ô∏è Falha na estrat√©gia ${strategy.description}:`, error.message);
        lastError = error;
                
        // Se n√£o foi timeout, tentar pr√≥xima estrat√©gia
        if (!error.message.includes('Timeout') && !error.message.includes('timeout')) {
          continue;
        }
      }
    }
        
    if (!navigationSuccess) {
      console.error('‚ùå Todas as estrat√©gias de navega√ß√£o falharam');
      this.sendStatus('error', `Erro na navega√ß√£o: ${lastError?.message || 'Timeout em todas as tentativas'}`, 35, 'Falha na navega√ß√£o');
      throw lastError || new Error('Falha em todas as estrat√©gias de navega√ß√£o');
    }
        
    // Verificar se chegou na p√°gina correta e limpar novamente
    const currentUrl = this.page.url();
    console.log(`‚úÖ URL atual ap√≥s navega√ß√£o: ${currentUrl}`);
    
    // Final cleanup para garantir p√°gina limpa
    try {
      await this.closeAnyModals();
      await this.contextualDelay('elementWait', { priority: 'normal' });
      console.log('‚úÖ P√°gina limpa e pronta para processar');
    } catch (finalCleanError) {
      console.log('‚ö†Ô∏è Erro na limpeza final:', finalCleanError.message);
    }
    
    // Registrar fim da navega√ß√£o
    this.performanceMonitor.recordNavigationEnd('navigateDirectlyToPerson', Date.now() - startTime);
  }

  async searchByCPF(cpf) {
    const searchStartTime = Date.now();
    this.performanceMonitor.recordElementSearchStart('searchByCPF');
    
    this.sendStatus('info', 'Buscando por CPF...', 35, `CPF: ${cpf}`);
        
    const cpfLimpo = cpf.replace(/\D/g, '');
        
    // Debug: verificar URL atual
    const currentUrl = this.page.url();
    console.log(`üîç URL atual: ${currentUrl}`);
        
    // Aguardar a p√°gina carregar completamente
    await this.page.waitForLoadState('networkidle');
        
    // M√∫ltiplos seletores para campo de busca
    const searchCandidates = [
      this.page.locator('input[placeholder*="CPF"]'),
      this.page.locator('input[placeholder*="cpf"]'),
      this.page.locator('input[name="cpf"]'),
      this.page.locator('#cpf'),
      this.page.locator('input[placeholder*="nome"]'),
      this.page.locator('input[name="nome"]'),
      this.page.locator('#nome'),
      this.page.locator('input[type="text"]'),
      this.page.locator('.form-control'),
      this.page.locator('input[class*="form"]'),
      this.page.locator('input[class*="input"]'),
      this.page.locator('input[id*="search"]'),
      this.page.locator('input[id*="busca"]'),
      this.page.locator('input[name*="search"]'),
      this.page.locator('input[name*="busca"]'),
      this.page.locator('input').first()
    ];
        
    let searchInput = null;
    for (let i = 0; i < searchCandidates.length; i++) {
      const candidate = searchCandidates[i];
      const count = await candidate.count();
      console.log(`Candidato ${i + 1} para busca: ${count} elementos encontrados`);
      if (count > 0) {
        try {
          await candidate.first().waitFor({ timeout: 3000 });
          searchInput = candidate.first();
          console.log(`‚úÖ Usando candidato ${i + 1} para busca`);
          break;
        } catch (e) {
          console.log(`Candidato ${i + 1} n√£o est√° vis√≠vel`);
        }
      }
    }
        
    if (!searchInput) {
      throw new Error('Campo de busca por CPF n√£o foi encontrado');
    }
        
    // Limpar e digitar o CPF
    await searchInput.clear();
    await searchInput.fill(cpfLimpo);
        
    // Tentar clicar no bot√£o "Procurar"
    const searchButtonCandidates = [
      this.page.locator('button:has-text("Procurar")'),
      this.page.locator('input[type="submit"][value*="Procurar"]'),
      this.page.locator('button[type="submit"]'),
      this.page.locator('.btn:has-text("Procurar")'),
      this.page.locator('input[value="Procurar"]'),
      this.page.locator('button:has-text("Buscar")'),
      this.page.locator('input[type="submit"]')
    ];
        
    let searchButtonClicked = false;
    for (let i = 0; i < searchButtonCandidates.length; i++) {
      const candidate = searchButtonCandidates[i];
      const count = await candidate.count();
      console.log(`Candidato ${i + 1} para bot√£o Procurar: ${count} elementos encontrados`);
      if (count > 0) {
        try {
          await candidate.first().waitFor({ timeout: 2000 });
          await candidate.first().click();
          console.log(`‚úÖ Clicou no bot√£o Procurar (candidato ${i + 1})`);
          searchButtonClicked = true;
          break;
        } catch (e) {
          console.log(`Candidato ${i + 1} para bot√£o Procurar n√£o est√° clic√°vel`);
        }
      }
    }
        
    // Se n√£o conseguiu clicar no bot√£o, usar Enter
    if (!searchButtonClicked) {
      console.log('‚ö†Ô∏è Bot√£o Procurar n√£o encontrado, usando Enter como alternativa');
      await searchInput.press('Enter');
    }
        
    // Aguardar os resultados carregarem
    await this.contextualDelay('searchPJE', { priority: 'high' });
        
    this.sendStatus('success', 'Busca realizada', 40, 'CPF encontrado');
    this.performanceMonitor.recordElementSearchEnd('searchByCPF', Date.now() - searchStartTime, true);
  }

  async navigateToServerTab() {
    this.sendStatus('info', 'Navegando para aba Servidor...', 45, 'Acessando perfil');
    
    let editSuccessful = false;
    
    try {
      // Clicar no √≠cone de edi√ß√£o
      await this.clickEditIcon();
      editSuccessful = true;
      console.log('‚úÖ √çcone de edi√ß√£o clicado com sucesso');
      
      // Aguardar navega√ß√£o
      await this.contextualDelay('networkWait', { priority: 'normal' });
      
      // Clicar na aba Servidor
      await this.clickServerTab();
      
    } catch (editError) {
      console.error('‚ùå Falha ao clicar no √≠cone de edi√ß√£o:', editError.message);
      
      // ESTRAT√âGIA DE FALLBACK: Tentar navegar diretamente para a p√°gina de edi√ß√£o
      console.log('üîÑ TENTANDO FALLBACK: Navega√ß√£o direta para edi√ß√£o');
      
      try {
        const currentUrl = this.page.url();
        console.log(`üìç URL atual: ${currentUrl}`);
        
        // Se j√° estamos na p√°gina de pessoa, tentar URLs diretas de edi√ß√£o
        if (currentUrl.includes('pessoa-fisica')) {
          const possibleEditUrls = [
            currentUrl.replace('pessoa-fisica', 'pessoa-fisica/alterar'),
            currentUrl.replace('pessoa-fisica', 'pessoa-fisica/editar'),
            currentUrl + '/alterar',
            currentUrl + '/editar',
            currentUrl.includes('?') ? currentUrl + '&acao=alterar' : currentUrl + '?acao=alterar'
          ];
          
          for (const editUrl of possibleEditUrls) {
            try {
              console.log(`üîó Tentando URL direta: ${editUrl}`);
              await this.navigationOptimizer.fastNavigate(this.page, editUrl);
              await this.contextualDelay('networkWait', { priority: 'normal' });
              
              // Verificar se chegamos numa p√°gina de edi√ß√£o (procurar pela aba Servidor)
              const serverTabExists = await this.page.$('text=Servidor, a[href*="servidor"], button:has-text("Servidor")');
              if (serverTabExists) {
                console.log('‚úÖ FALLBACK SUCEDIDO: P√°gina de edi√ß√£o alcan√ßada');
                editSuccessful = true;
                
                // Tentar clicar na aba servidor
                await this.clickServerTab();
                break;
              } else {
                console.log('‚ùå URL n√£o levou √† p√°gina de edi√ß√£o');
              }
              
            } catch (urlError) {
              console.log(`‚ùå Falha na URL ${editUrl}: ${urlError.message}`);
            }
          }
        }
        
        // Se ainda n√£o conseguimos, tentar uma √∫ltima estrat√©gia
        if (!editSuccessful) {
          console.log('üö® ESTRAT√âGIA FINAL: Buscar por qualquer link/form de edi√ß√£o na p√°gina atual');
          
          const currentPageContent = await this.page.content();
          if (currentPageContent.includes('servidor') || currentPageContent.includes('Servidor')) {
            console.log('‚úÖ Conte√∫do de servidor detectado na p√°gina atual');
            
            // Tentar encontrar e clicar na aba servidor diretamente
            await this.clickServerTab();
            editSuccessful = true;
          }
        }
        
      } catch (fallbackError) {
        console.error('‚ùå Estrat√©gias de fallback falharam:', fallbackError.message);
        throw new Error(`N√£o foi poss√≠vel acessar a p√°gina de edi√ß√£o: ${editError.message} | Fallback: ${fallbackError.message}`);
      }
    }
    
    if (editSuccessful) {
      this.sendStatus('success', 'Aba Servidor acessada', 50, 'Pronto para processar OJs');
    } else {
      throw new Error('Falha completa ao acessar a aba Servidor');
    }
  }

  async clickEditIcon() {
    const clickStartTime = Date.now();
    this.performanceMonitor.recordClickStart('clickEditIcon');
    
    console.log('üéØ VERS√ÉO MELHORADA: Detec√ß√£o robusta de √≠cone de edi√ß√£o...');
    
    // Debug: verificar elementos vis√≠veis na p√°gina
    try {
      const pageContent = await this.page.content();
      console.log(`üìÑ URL atual: ${this.page.url()}`);
      
      // Verificar se h√° tabela na p√°gina
      const hasTable = pageContent.includes('<table') || pageContent.includes('datatable');
      console.log(`üóÇÔ∏è Tabela detectada: ${hasTable}`);
      
      // Procurar por elementos que podem ser bot√µes de edi√ß√£o (limitado para performance)
      try {
        const potentialButtons = await this.page.$$eval('button, a', elements => 
          elements.slice(0, 20).map(el => ({
            tagName: el.tagName,
            text: el.textContent?.trim().substring(0, 50),
            title: el.title,
            className: el.className?.substring(0, 100)
          }))
        );
        console.log('üîò Primeiros bot√µes/links encontrados:', potentialButtons);
      } catch (evalError) {
        console.log('‚ö†Ô∏è Erro ao listar bot√µes:', evalError.message);
      }
    } catch (debugError) {
      console.log('‚ö†Ô∏è Erro no debug:', debugError.message);
    }

    // Seletores CORRETOS baseados no HTML fornecido pelo usu√°rio
    const editSelectors = [
      // Seletores espec√≠ficos baseados no c√≥digo real
      'button[aria-label="Alterar pessoa"]',
      'button[mattooltip="Alterar pessoa"]',
      'button:has(i.fa-pencil-alt)',
      '.visivel-hover',
      'button.visivel-hover',
      '.fa-pencil-alt',
      'i.fa-pencil-alt',
      'i.fas.fa-pencil-alt',
      '#cdk-drop-list-1 > tr > td:nth-child(6) > button',
      'td:nth-child(6) button',
      'td:nth-child(6) .visivel-hover',
      
      // Fallbacks gen√©ricos
      'button[title*="Alterar"]',
      'a[title*="Alterar"]', 
      '.fa-edit',
      '.fa-pencil'
    ];
        
    let editButton = null;
    let editButtonElement = null;
    
    // NOVA ESTRAT√âGIA 1: For√ßar visibilidade e fazer hover intensivo
    console.log('üîß ESTRAT√âGIA 1: For√ßando visibilidade e hover intensivo...');
    
    try {
      // 1.1: For√ßar visibilidade via JavaScript
      await this.page.evaluate(() => {
        // For√ßar todos os elementos .visivel-hover serem vis√≠veis
        const hoverElements = document.querySelectorAll('.visivel-hover, button[aria-label="Alterar pessoa"]');
        console.log(`For√ßando visibilidade em ${hoverElements.length} elementos`);
        
        hoverElements.forEach((element, index) => {
          element.style.visibility = 'visible';
          element.style.opacity = '1'; 
          element.style.display = 'inline-block';
          element.style.pointerEvents = 'auto';
          console.log(`Elemento ${index + 1} for√ßado a ser vis√≠vel`);
        });
        
        return hoverElements.length;
      });
      
      console.log('‚úÖ Visibilidade for√ßada via JavaScript');
      
      // 1.2: Fazer hover intensivo em todas as linhas da tabela (otimizado)
      const allRows = await this.page.$$('table tbody tr, .table tbody tr, .datatable tbody tr, #cdk-drop-list-1 > tr');
      console.log(`üìã Fazendo hover intensivo em ${allRows.length} linhas...`);
      
      for (let i = 0; i < Math.min(allRows.length, 3); i++) {
        const row = allRows[i];
        try {
          console.log(`üñ±Ô∏è Hover intensivo na linha ${i + 1}...`);
          await row.hover();
          await this.delay(1000);
          
          // Verificar imediatamente se bot√µes apareceram
          const buttonsInRow = await row.$$('button[aria-label="Alterar pessoa"], .visivel-hover, i.fa-pencil-alt');
          if (buttonsInRow.length > 0) {
            console.log(`‚úÖ ${buttonsInRow.length} bot√µes encontrados ap√≥s hover na linha ${i + 1}`);
            
            for (const btn of buttonsInRow) {
              const isVisible = await btn.isVisible();
              if (isVisible) {
                editButtonElement = btn;
                editButton = `Hover linha ${i + 1} - bot√£o vis√≠vel`;
                console.log(`üéØ SUCESSO: ${editButton}`);
                break;
              }
            }
            
            if (editButtonElement) break;
          }
        } catch (hoverRowError) {
          console.log(`‚ö†Ô∏è Erro hover linha ${i + 1}:`, hoverRowError.message);
        }
      }
      
    } catch (forceError) {
      console.log('‚ö†Ô∏è Erro na estrat√©gia de for√ßa:', forceError.message);
    }
    
    // ESTRAT√âGIA 2: Clique direto na linha se n√£o encontrou bot√µes 
    if (!editButtonElement) {
      console.log('üéØ ESTRAT√âGIA 2: Clique direto na linha da tabela...');
      try {
        const firstRow = await this.page.$('table tbody tr:first-child, .table tbody tr:first-child, .datatable tbody tr:first-child, #cdk-drop-list-1 > tr:first-child');
        if (firstRow) {
          console.log('‚úÖ Executando clique direto na primeira linha...');
          
          // Primeiro fazer hover para garantir
          await firstRow.hover();
          await this.delay(500);
          
          // Ent√£o clicar
          await firstRow.click();
          await this.delay(3000);
          
          // Verificar se mudou de p√°gina
          const currentUrl = this.page.url();
          console.log(`üìç URL ap√≥s clique: ${currentUrl}`);
          
          if (currentUrl.includes('editar') || currentUrl.includes('edit') || currentUrl.includes('detalhes')) {
            console.log('üéØ SUCESSO: Navega√ß√£o por clique na linha realizada!');
            editButtonElement = firstRow;
            editButton = 'Clique direto na linha da tabela';
          } else {
            console.log('‚ö†Ô∏è Clique na linha n√£o levou √† p√°gina de edi√ß√£o, tentando double-click...');
            
            await firstRow.dblclick();
            await this.delay(3000);
            
            const newUrl = this.page.url();
            if (newUrl !== currentUrl && (newUrl.includes('editar') || newUrl.includes('edit'))) {
              console.log('üéØ SUCESSO: Navega√ß√£o por double-click realizada!');
              editButtonElement = firstRow;
              editButton = 'Double-click na linha da tabela';
            }
          }
        }
      } catch (directClickError) {
        console.log('‚ö†Ô∏è Erro no clique direto:', directClickError.message);
      }
    }
    
    // ESTRAT√âGIA 3: Seletores tradicionais (apenas se estrat√©gias anteriores falharam)
    if (!editButtonElement) {
      console.log('üîç ESTRAT√âGIA 3: Testando seletores tradicionais...');
      
      for (const selector of editSelectors) {
        try {
          console.log(`üîç Testando seletor: ${selector}`);
        
          // Timeout muito reduzido para chegar logo nas estrat√©gias especiais
          await this.page.waitForSelector(selector, { timeout: 500, state: 'attached' });
        
          // Obter o elemento (otimizado)
          editButtonElement = await this.page.$(selector);
        
          if (editButtonElement) {
          // Verificar se est√° vis√≠vel
            const isVisible = await editButtonElement.isVisible();
            if (isVisible) {
              editButton = selector;
              console.log(`‚úÖ √çcone de edi√ß√£o encontrado e vis√≠vel: ${selector}`);
              break;
            } else {
              console.log(`‚ö†Ô∏è Elemento ${selector} existe mas n√£o est√° vis√≠vel`);
            }
          }
        } catch (error) {
        // Log simplificado para n√£o poluir
          console.log(`‚ùå ${selector} (timeout 500ms)`);
        }
      }
    }

    // Estrat√©gia alternativa se nenhum seletor funcionou
    if (!editButton || !editButtonElement) {
      console.log('üîÑ ===== SELETORES TRADICIONAIS FALHARAM - INICIANDO ESTRAT√âGIAS ESPECIAIS =====');
      console.log('üîÑ ESTRAT√âGIA ALTERNATIVA: An√°lise completa da tabela');
      try {
        // Primeiro, tentar encontrar qualquer tabela (otimizado)
        const tableExists = await this.page.$('table, .table, .datatable');
        if (tableExists) {
          console.log('‚úÖ Tabela encontrada, analisando linhas...');
          
          // Buscar todas as linhas da tabela (otimizado)
          const rows = await this.page.$$('table tbody tr, .table tbody tr, .datatable tbody tr');
          console.log(`üóÇÔ∏è Encontradas ${rows.length} linhas na tabela`);
          
          if (rows.length > 0) {
            // Analisar a primeira linha para entender a estrutura
            const firstRow = rows[0];
            
            // ESTRAT√âGIA ESPEC√çFICA PARA PJE: Hover na linha para revelar bot√µes
            console.log('üñ±Ô∏è Fazendo hover na primeira linha para revelar bot√µes...');
            try {
              await firstRow.hover();
              await this.contextualDelay('elementWait', { priority: 'high' }); // Aguardar bot√µes aparecerem
              console.log('‚úÖ Hover realizado na linha');
            } catch (hoverError) {
              console.log('‚ö†Ô∏è Erro no hover:', hoverError.message);
            }
            
            // Buscar elementos clic√°veis em toda a linha ap√≥s hover
            const allRowElements = await firstRow.$$('button, a, i, span[onclick], div[onclick], .fa, .fas, .far, [class*="edit"], [class*="pencil"], [title*="Alterar"], [title*="Editar"]');
            console.log(`üîò Elementos clic√°veis/√≠cones na linha: ${allRowElements.length}`);
            
            for (let i = 0; i < allRowElements.length; i++) {
              const element = allRowElements[i];
              try {
                const tagName = await element.evaluate(el => el.tagName);
                const text = await element.evaluate(el => el.textContent?.trim() || '');
                const title = await element.evaluate(el => el.title || '');
                const className = await element.evaluate(el => el.className || '');
                const isVisible = await element.isVisible();
                
                console.log(`üîç Elemento linha ${i + 1}: ${tagName} | "${text}" | Title:"${title}" | Class:"${className}" | Vis√≠vel:${isVisible}`);
                
                // Se √© vis√≠vel e parece ser de edi√ß√£o
                if (isVisible && !text.toLowerCase().includes('excluir') && !text.toLowerCase().includes('delete') && 
                    !className.toLowerCase().includes('delete') && !title.toLowerCase().includes('excluir')) {
                  
                  // Priorizar elementos com indica√ß√£o de edi√ß√£o
                  const hasEditIndication = text.toLowerCase().includes('alterar') || 
                                          text.toLowerCase().includes('editar') ||
                                          title.toLowerCase().includes('alterar') || 
                                          title.toLowerCase().includes('editar') ||
                                          className.includes('edit') || 
                                          className.includes('pencil') ||
                                          className.includes('fa-edit') ||
                                          className.includes('fa-pencil');
                  
                  if (hasEditIndication || (!editButtonElement && tagName === 'BUTTON') || (!editButtonElement && tagName === 'A')) {
                    editButtonElement = element;
                    editButton = `Linha elemento ${i + 1} (${tagName}) - "${text}"`;
                    console.log(`‚úÖ SELECIONADO da linha: ${editButton}`);
                    
                    if (hasEditIndication) {
                      console.log('üéØ Elemento com indica√ß√£o clara de edi√ß√£o - interrompendo busca');
                      break;
                    }
                  }
                }
              } catch (elementError) {
                console.log(`‚ö†Ô∏è Erro ao analisar elemento linha ${i + 1}:`, elementError.message);
              }
            }
            
            // Se n√£o encontrou na linha, verificar c√©lulas individualmente
            if (!editButtonElement) {
              const cells = await firstRow.$$('td');
              console.log(`üìã Analisando ${cells.length} colunas individualmente...`);
              
              for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                const cell = cells[cellIndex];
                
                // Fazer hover na c√©lula tamb√©m
                try {
                  await cell.hover();
                  await this.contextualDelay('click', { priority: 'high' });
                } catch (cellHoverError) {
                  console.log(`‚ö†Ô∏è Erro hover c√©lula ${cellIndex + 1}:`, cellHoverError.message);
                }
                
                const cellElements = await cell.$$('button, a, i, span, div');
                console.log(`üì¶ C√©lula ${cellIndex + 1}: ${cellElements.length} elementos`);
                
                for (const cellElement of cellElements) {
                  try {
                    const isVisible = await cellElement.isVisible();
                    if (isVisible && !editButtonElement) {
                      const tagName = await cellElement.evaluate(el => el.tagName);
                      const text = await cellElement.evaluate(el => el.textContent?.trim() || '');
                      
                      console.log(`üì¶ C√©lula ${cellIndex + 1} - ${tagName}: "${text}"`);
                      
                      if ((tagName === 'BUTTON' || tagName === 'A') && !text.toLowerCase().includes('excluir')) {
                        editButtonElement = cellElement;
                        editButton = `C√©lula ${cellIndex + 1} elemento (${tagName})`;
                        console.log(`‚úÖ SELECIONADO da c√©lula: ${editButton}`);
                        break;
                      }
                    }
                  } catch (cellElementError) {
                    console.log('‚ö†Ô∏è Erro elemento da c√©lula:', cellElementError.message);
                  }
                }
                
                if (editButtonElement) break;
              }
            }
          }
        }
        
        // √öltima tentativa: buscar por qualquer bot√£o/link vis√≠vel que n√£o seja "excluir"
        if (!editButton || !editButtonElement) {
          console.log('üîÑ PEN√öLTIMA TENTATIVA: Busca por qualquer elemento clic√°vel com indica√ß√£o de edi√ß√£o');
          
          const allClickableElements = await this.page.$$('button:visible, a:visible');
          console.log(`üîò Total de elementos clic√°veis vis√≠veis: ${allClickableElements.length}`);
          
          for (let i = 0; i < Math.min(allClickableElements.length, 15); i++) { // Aumentar para 15 elementos
            const element = allClickableElements[i];
            try {
              const text = await element.evaluate(el => el.textContent?.trim() || '');
              const title = await element.evaluate(el => el.title || '');
              const className = await element.evaluate(el => el.className || '');
              
              // Se n√£o √© bot√£o de exclus√£o e cont√©m indica√ß√£o de edi√ß√£o
              if (!text.toLowerCase().includes('excluir') && !text.toLowerCase().includes('delete') &&
                  !title.toLowerCase().includes('excluir') && !className.toLowerCase().includes('delete') &&
                  (text.toLowerCase().includes('alterar') || text.toLowerCase().includes('editar') || 
                   title.toLowerCase().includes('alterar') || title.toLowerCase().includes('editar') ||
                   className.includes('edit') || className.includes('pencil'))) {
                
                editButtonElement = element;
                editButton = `Elemento global: "${text}" (${title})`;
                console.log(`‚úÖ ENCONTRADO elemento de edi√ß√£o global: ${editButton}`);
                break;
              }
            } catch (globalError) {
              console.log(`‚ö†Ô∏è Erro ao analisar elemento global ${i + 1}:`, globalError.message);
            }
          }
        }
        
        // ESTRAT√âGIA 4: Navega√ß√£o direta por URL
        if (!editButton || !editButtonElement) {
          console.log('üîó ESTRAT√âGIA 4: Navega√ß√£o direta por URL...');
          
          try {
            const currentUrl = this.page.url();
            console.log(`üìç URL atual: ${currentUrl}`);
            
            // Tentar diferentes padr√µes de URL de edi√ß√£o
            const editUrlPatterns = [
              currentUrl.replace('/pessoa-fisica', '/pessoa-fisica/edit'),
              currentUrl.replace('/pessoa-fisica', '/pessoa-fisica/editar'),
              currentUrl + '/edit',
              currentUrl + '/editar',
              currentUrl + '/detalhes'
            ];
            
            for (const editUrl of editUrlPatterns) {
              try {
                console.log(`üîó Tentando navegar para: ${editUrl}`);
                await this.navigationOptimizer.optimizedNavigate(this.page, editUrl);
                
                const finalUrl = this.page.url();
                console.log(`üìç URL final: ${finalUrl}`);
                
                if (finalUrl.includes('edit') || finalUrl.includes('editar') || finalUrl.includes('detalhes')) {
                  console.log('‚úÖ SUCESSO: Navega√ß√£o direta realizada!');
                  editButton = `Navega√ß√£o direta: ${editUrl}`;
                  editButtonElement = 'direct-navigation';
                  break;
                }
              } catch (urlError) {
                console.log(`‚ö†Ô∏è Erro na navega√ß√£o para ${editUrl}:`, urlError.message);
              }
            }
          } catch (directNavError) {
            console.log('‚ùå Erro na navega√ß√£o direta:', directNavError.message);
          }
        }
        
        // ESTRAT√âGIA 5: √öltima tentativa com clique em elementos
        if (!editButton || !editButtonElement) {
          console.log('üö® ESTRAT√âGIA 5: √öltima tentativa com elementos da linha...');
          
          try {
            // Buscar primeira linha da tabela
            const firstRow = await this.domCache.findElement('table tbody tr:first-child, .table tbody tr:first-child, .datatable tbody tr:first-child');
            if (firstRow) {
              console.log('‚úÖ Primeira linha encontrada para clique direto');
              
              // Primeiro, tentar encontrar elementos clic√°veis
              const rowClickables = await firstRow.$$('button, a, i, span[onclick], [onclick]');
              console.log(`üîò Elementos com potencial de clique: ${rowClickables.length}`);
              
              if (rowClickables.length > 0) {
                for (let i = 0; i < rowClickables.length; i++) {
                  const element = rowClickables[i];
                  try {
                    const isVisible = await element.isVisible();
                    if (isVisible) {
                      const text = await element.evaluate(el => el.textContent?.trim() || '');
                      const title = await element.evaluate(el => el.title || '');
                      const className = await element.evaluate(el => el.className || '');
                      
                      console.log(`üîç Elemento ${i + 1}: Texto="${text}" Title="${title}" Class="${className}"`);
                      
                      // Evitar apenas bot√µes que CLARAMENTE s√£o de exclus√£o
                      const isDeleteButton = text.toLowerCase().includes('excluir') || 
                                           text.toLowerCase().includes('delete') || 
                                           title.toLowerCase().includes('excluir') ||
                                           className.toLowerCase().includes('delete');
                      
                      if (!isDeleteButton) {
                        editButtonElement = element;
                        editButton = `DESESPERADO - Elemento ${i + 1}: "${text}" (${title})`;
                        console.log(`üö® USANDO ESTRAT√âGIA DESESPERADA: ${editButton}`);
                        break;
                      }
                    }
                  } catch (desperateError) {
                    console.log(`‚ö†Ô∏è Erro na an√°lise desesperada ${i + 1}:`, desperateError.message);
                  }
                }
              } else {
                // √öLTIMA TENTATIVA FINAL: Clicar na primeira c√©lula que n√£o seja ID
                console.log('üö® TENTATIVA EXTREMA: Clicar na c√©lula do nome para abrir detalhes');
                
                const cells = await firstRow.$$('td');
                console.log(`üìã C√©lulas dispon√≠veis: ${cells.length}`);
                
                if (cells.length >= 2) {
                  // Geralmente a segunda c√©lula √© o nome (primeira √© ID)
                  const nameCell = cells[1];
                  
                  // Fazer hover primeiro
                  await nameCell.hover();
                  await this.delay(500);
                  
                  // Verificar se apareceram elementos clic√°veis ap√≥s hover
                  const afterHoverElements = await nameCell.$$('a, button, [onclick]');
                  if (afterHoverElements.length > 0 && await afterHoverElements[0].isVisible()) {
                    editButtonElement = afterHoverElements[0];
                    editButton = 'EXTREMO - Elemento da c√©lula nome ap√≥s hover';
                    console.log('üö® EXTREMO: Usando elemento que apareceu ap√≥s hover no nome');
                  } else {
                    // Se ainda n√£o h√° elementos clic√°veis, clicar na pr√≥pria c√©lula do nome
                    editButtonElement = nameCell;
                    editButton = 'EXTREMO - C√©lula do nome diretamente';
                    console.log('üö® EXTREMO: Clicando diretamente na c√©lula do nome');
                  }
                }
              }
            }
          } catch (desperateError) {
            console.log('‚ùå Estrat√©gia desesperada falhou:', desperateError.message);
          }
        }
        
      } catch (altError) {
        console.error('‚ùå Estrat√©gia alternativa completa falhou:', altError.message);
        console.error('Stack trace:', altError.stack);
      }
    }
        
    if (!editButton || !editButtonElement) {
      console.error('‚ùå ===== FALHA TOTAL: NENHUM √≠cone de edi√ß√£o encontrado ap√≥s TODAS as tentativas =====');
      
      // Debug final: salvar screenshot para diagn√≥stico
      try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const screenshotPath = `debug-no-edit-${timestamp}.png`;
        await this.page.screenshot({ path: screenshotPath, fullPage: true });
        console.log(`üì∏ Screenshot de debug salvo: ${screenshotPath}`);
      } catch (screenshotError) {
        console.log('‚ùå Erro ao salvar screenshot:', screenshotError.message);
      }
      
      throw new Error('√çcone de edi√ß√£o n√£o encontrado ap√≥s m√∫ltiplas estrat√©gias');
    }
        
    // Clicar no elemento encontrado ou verificar navega√ß√£o direta
    console.log(`üñ±Ô∏è Processando a√ß√£o: ${editButton}`);
    
    if (editButtonElement === 'direct-navigation') {
      console.log('‚úÖ Navega√ß√£o direta j√° realizada - verificando p√°gina atual');
      const currentUrl = this.page.url();
      if (currentUrl.includes('edit') || currentUrl.includes('editar') || currentUrl.includes('detalhes')) {
        console.log('‚úÖ Navega√ß√£o direta confirmada com sucesso');
      } else {
        throw new Error('Navega√ß√£o direta n√£o levou √† p√°gina esperada');
      }
    } else {
      try {
        // Scroll para o elemento antes de clicar
        await editButtonElement.scrollIntoViewIfNeeded();
        await this.delay(500);
        
        // Clicar no elemento
        await editButtonElement.click();
        await this.delay(3000); // Aguardar navega√ß√£o
        
        console.log('‚úÖ Clique no √≠cone de edi√ß√£o executado com sucesso');
        this.performanceMonitor.recordClickEnd('clickEditIcon', Date.now() - clickStartTime, true);
      } catch (clickError) {
        console.error('‚ùå Erro ao clicar no √≠cone de edi√ß√£o:', clickError.message);
        this.performanceMonitor.recordClickEnd('clickEditIcon', Date.now() - clickStartTime, false);
        throw new Error(`Falha ao clicar no √≠cone de edi√ß√£o: ${clickError.message}`);
      }
    }
    
    // Registrar fim da opera√ß√£o se n√£o houve clique
    this.performanceMonitor.recordClickEnd('clickEditIcon', Date.now() - clickStartTime, false);
  }

  async clickServerTab() {
    const servidorSelectors = [
      'text=Servidor',
      'a[href*="servidor"]',
      'button:has-text("Servidor")',
      'a:has-text("Servidor")',
      '[role="tab"]:has-text("Servidor")',
      'li:has-text("Servidor") a',
      '//a[contains(text(), "Servidor")]',
      '//button[contains(text(), "Servidor")]'
    ];
        
    let servidorTab = null;
        
    for (const selector of servidorSelectors) {
      try {
        await this.page.waitForSelector(selector, { timeout: 2000 });
        servidorTab = selector;
        console.log(`‚úÖ Aba Servidor encontrada: ${selector}`);
        break;
      } catch (error) {
        console.log(`Seletor aba Servidor ${selector} n√£o encontrado`);
      }
    }
        
    if (!servidorTab) {
      throw new Error('Aba Servidor n√£o encontrada');
    }
        
    await this.retryManager.retryClick(
        async (selector) => {
          const element = await this.page.$(selector);
          if (element) {
            await element.click();
          } else {
            throw new Error('Element not found');
          }
        },
        servidorTab
      );
    await this.delay(2000);
  }

  async processOrgaosJulgadores() {
    this.sendStatus('info', 'Iniciando processamento paralelo dos OJs...', 55, 'Otimizando performance');
    
    try {
      // Inicializar processador paralelo
      if (!this.parallelProcessor) {
        this.parallelProcessor = new ParallelOJProcessor(
          this.page, 
          this.timeoutManager, 
          this.config,
          this.domCache
        );
      }
      
      // Usar processamento paralelo otimizado
      const startTime = Date.now();
      const results = await this.parallelProcessor.processOJsInParallel(this.config.orgaos);
      const duration = Date.now() - startTime;
      
      // Consolidar resultados
      this.results = results;
      
      // Atualizar cache local
      this.ojCache = this.parallelProcessor.ojCache;
      
      const sucessos = results.filter(r => r.status.includes('Sucesso')).length;
      const erros = results.filter(r => r.status === 'Erro').length;
      const jaIncluidos = results.filter(r => r.status.includes('J√°')).length;
      
      this.sendStatus('success', 
        `Processamento paralelo conclu√≠do em ${(duration/1000).toFixed(1)}s`, 
        95, 
        `${sucessos} sucessos, ${erros} erros, ${jaIncluidos} j√° inclu√≠dos`
      );
      
      console.log(`üöÄ Processamento paralelo conclu√≠do:`);
      console.log(`   ‚úÖ Sucessos: ${sucessos}`);
      console.log(`   ‚ùå Erros: ${erros}`);
      console.log(`   üìã J√° inclu√≠dos: ${jaIncluidos}`);
      console.log(`   ‚è±Ô∏è Tempo total: ${(duration/1000).toFixed(1)}s`);
      console.log(`   üìä Performance: ${(results.length / (duration/1000)).toFixed(1)} OJs/s`);
      
    } catch (error) {
      console.error('‚ùå Erro no processamento paralelo:', error);
      this.sendStatus('error', `Erro no processamento paralelo: ${error.message}`, 60, 'Tentando fallback');
      
      // Fallback para processamento sequencial
      await this.processOrgaosJulgadoresSequential();
    }
  }
  
  /**
   * Fallback para processamento sequencial (m√©todo original)
   */
  async processOrgaosJulgadoresSequential() {
    this.sendStatus('info', 'Usando processamento sequencial (fallback)...', 55, 'Verificando OJs cadastrados');
        
    // Verificar OJs j√° cadastrados em lote (otimiza√ß√£o com cache)
    await this.loadExistingOJs();
        
    // Normalizar e filtrar OJs que precisam ser processados
    const ojsNormalizados = this.config.orgaos.map(orgao => this.normalizeOrgaoName(orgao));
    const ojsToProcess = ojsNormalizados.filter(orgao => !this.ojCache.has(orgao));
        
    this.sendStatus('info', `${ojsToProcess.length} OJs para processar`, 60, `${this.ojCache.size} j√° cadastrados`);
        
    // Processar cada OJ restante
    for (let i = 0; i < ojsToProcess.length; i++) {
      const orgao = ojsToProcess[i];
      const progress = 60 + (i / ojsToProcess.length) * 35;
            
      this.sendStatus('info', `Processando OJ ${i + 1}/${ojsToProcess.length}`, progress, orgao);
            
      try {
        await this.processOrgaoJulgador(orgao);
        this.results.push({
          orgao,
          status: 'Inclu√≠do com Sucesso',
          erro: null,
          perfil: this.config.perfil,
          cpf: this.config.cpf,
          timestamp: new Date().toISOString()
        });
        this.sendStatus('success', 'OJ processado com sucesso', progress, orgao);
      } catch (error) {
        console.error(`Erro ao processar OJ ${orgao}:`, error);
        this.results.push({
          orgao,
          status: 'Erro',
          erro: error.message,
          cpf: this.config.cpf,
          timestamp: new Date().toISOString()
        });
        this.sendStatus('error', `Erro ao processar OJ: ${error.message}`, progress, orgao);
                
        // Prote√ß√µes ap√≥s erro
        await this.handleErrorRecovery();
      }
            
      // Pausa otimizada com timeouts adaptativos
      const delay = TimeoutManager.obterTimeout('pje', 'aguardarProcessamento') || 25;
      await this.delay(delay);
    }
        
    // Adicionar OJs j√° existentes ao relat√≥rio
    for (const orgaoExistente of this.ojCache) {
      if (this.config.orgaos.includes(orgaoExistente)) {
        this.results.push({
          orgao: orgaoExistente,
          status: 'J√° Inclu√≠do',
          erro: null,
          perfil: this.config.perfil,
          cpf: this.config.cpf,
          timestamp: new Date().toISOString()
        });
      }
    }
  }

  async loadExistingOJs() {
    try {
      this.sendStatus('info', 'Verificando OJs j√° cadastrados...', 58, 'Otimizando processo');
      console.log('üîç Carregando OJs existentes para otimizar automa√ß√£o...');
      
      // Aguardar elementos carregarem rapidamente
      await this.page.waitForTimeout(500);
      
      // Seletores para encontrar tabela/lista de OJs j√° cadastrados
      const tabelaSelectors = [
        'table tbody tr', // Tabela padr√£o
        '.mat-table .mat-row', // Material Design table
        '.datatable tbody tr', // DataTable
        '[role="row"]', // ARIA rows
        '.lista-orgaos tr', // Lista espec√≠fica
        '.localizacoes-visibilidades tr' // Tabela de localiza√ß√µes
      ];
      
      const ojsEncontrados = new Set();
      
      for (const selector of tabelaSelectors) {
        try {
          const linhas = this.page.locator(selector);
          const numLinhas = await linhas.count();
          console.log(`üîç Seletor "${selector}": ${numLinhas} linhas encontradas`);
          
          if (numLinhas > 0) {
            // Extrair texto de cada linha para identificar OJs
            for (let i = 0; i < Math.min(numLinhas, 50); i++) { // Limitar a 50 para performance
              try {
                const textoLinha = await linhas.nth(i).textContent();
                if (textoLinha && textoLinha.trim()) {
                  // Procurar por padr√µes de OJ no texto
                  const ojMatches = textoLinha.match(/(EXE\d+|LIQ\d+|CON\d+|DIVEX|[\d¬∫]+¬™?\s*Vara\s+do\s+Trabalho)/gi);
                  if (ojMatches) {
                    ojMatches.forEach(match => {
                      const ojNormalizado = this.normalizeOrgaoName(match.trim());
                      ojsEncontrados.add(ojNormalizado);
                      console.log(`‚úÖ OJ encontrado: ${ojNormalizado}`);
                    });
                  }
                }
              } catch (erro) {
                // Ignorar erros de linha espec√≠fica
                continue;
              }
            }
            
            // Se encontrou OJs com este seletor, n√£o precisa tentar outros
            if (ojsEncontrados.size > 0) {
              console.log(`‚úÖ ${ojsEncontrados.size} OJs j√° cadastrados encontrados`);
              break;
            }
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è Seletor ${selector} falhou: ${error.message}`);
        }
      }
      
      // Adicionar OJs encontrados ao cache
      ojsEncontrados.forEach(oj => this.ojCache.add(oj));
      
      console.log(`üéØ Cache de OJs atualizado: ${this.ojCache.size} OJs j√° cadastrados`);
      this.sendStatus('success', `${this.ojCache.size} OJs j√° cadastrados identificados`, 60, 'Cache otimizado');
      
    } catch (error) {
      console.log('‚ö†Ô∏è Erro ao carregar OJs existentes:', error.message);
      // N√£o falhar a automa√ß√£o por erro no cache
    }
  }

  async processOrgaoJulgador(orgao) {
    const processStartTime = Date.now();
    this.performanceMonitor.recordPJEOperationStart('processOrgaoJulgador', orgao);
    
    console.log(`üöÄ INICIANDO processamento otimizado para: ${orgao}`);
    
    // Verifica√ß√£o r√°pida se OJ j√° est√° cadastrado (verifica√ß√£o dupla para garantir)
    const ojNormalizado = this.normalizeOrgaoName(orgao);
    if (this.ojCache.has(ojNormalizado)) {
      console.log(`‚ö° OJ j√° cadastrado (cache hit): ${orgao}`);
      this.results.push({
        orgao,
        status: 'J√° Inclu√≠do',
        erro: null,
        perfil: this.config.perfil,
        cpf: this.config.cpf,
        timestamp: new Date().toISOString()
      });
      
      // Registrar fim da opera√ß√£o PJE com sucesso (cache hit)
      this.performanceMonitor.recordPJEOperationEnd('processOrgaoJulgador', Date.now() - processStartTime, true);
      
      return; // Skip processamento
    }
    
    const startTime = Date.now();
    
    try {
      // ULTRA-R√ÅPIDO: Sem estabiliza√ß√£o desnecess√°ria
      console.log('üéØ PROCESSAMENTO ULTRA-ASSERTIVO INICIADO');
      console.log(`üîç DEBUG: CPF atual: ${this.config.cpf}`);
      console.log(`üîç DEBUG: Perfil atual: ${this.config.perfil}`);
      
      // Fechar modais rapidamente (se existirem)
      console.log('üîÑ ETAPA 0: Fechando modais existentes...');
      await this.closeAnyModalsRapido();
          
      // 1. A√á√ÉO: Clicar no bot√£o "Adicionar Localiza√ß√£o/Visibilidade"
      console.log(`üîÑ ETAPA 1: Abrindo modal de adi√ß√£o para OJ: ${orgao}`);
      await this.clickAddLocationButtonRapido();
          
      // 2. A√á√ÉO: Selecionar o OJ diretamente
      console.log(`üîÑ ETAPA 2: Selecionando OJ espec√≠fico: ${orgao}`);
      await this.selectOrgaoJulgadorRapido(orgao);
          
      // 3. A√á√ÉO: Configurar papel e visibilidade
      console.log(`üîÑ ETAPA 3: Configurando papel e visibilidade para OJ: ${orgao}`);
      await this.configurePapelVisibilidadeRapido();
          
      // 4. A√á√ÉO: Salvar
      console.log(`üîÑ ETAPA 4: Salvando configura√ß√£o para OJ: ${orgao}`);
      await this.saveConfigurationRapido();
          
      // 5. FINAL: Verificar sucesso
      console.log(`üîÑ ETAPA 5: Verificando sucesso da vincula√ß√£o para OJ: ${orgao}`);
      await this.verifySuccessRapido();
      
      const tempoDecorrido = Date.now() - startTime;
      console.log(`‚úÖ OJ processado com SUCESSO em ${tempoDecorrido}ms: ${orgao}`);
      
      // Adicionar ao cache para pr√≥ximas verifica√ß√µes
      this.ojCache.add(ojNormalizado);
      
      // Adicionar resultado de sucesso
      this.results.push({
        orgao,
        status: 'Vinculado com Sucesso',
        erro: null,
        perfil: this.config.perfil,
        cpf: this.config.cpf,
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      const tempoDecorrido = Date.now() - startTime;
      console.error(`‚ùå ERRO ap√≥s ${tempoDecorrido}ms processando OJ ${orgao}:`, error.message);
      console.error('‚ùå Stack trace completo:', error.stack);
      
      // Adicionar resultado de erro
      this.results.push({
        orgao,
        status: 'Erro na Vincula√ß√£o',
        erro: error.message,
        perfil: this.config.perfil,
        cpf: this.config.cpf,
        timestamp: new Date().toISOString()
      });
      
      // Registrar fim da opera√ß√£o PJE com erro
      this.performanceMonitor.recordPJEOperationEnd('processOrgaoJulgador', Date.now() - processStartTime, false);
      
      throw error;
    }
  }

  // === FUN√á√ïES OTIMIZADAS PARA VELOCIDADE ===
  
  async closeAnyModalsRapido() {
    console.log('‚ö° Fechando modais rapidamente...');
    const modalCloseSelectors = [
      '.mat-overlay-backdrop',
      '.cdk-overlay-backdrop',
      '.modal-backdrop',
      'button:has-text("OK")',
      'button:has-text("Fechar")'
    ];
        
    for (const selector of modalCloseSelectors) {
      try {
        // Usar page.$$ diretamente para evitar timeout longo do domCache
        const element = await this.page.$(selector);
        if (element) {
          const isVisible = await element.isVisible();
          if (isVisible) {
            await element.click();
            console.log(`‚ö° Modal fechado: ${selector}`);
            await this.page.waitForTimeout(50); // Delay muito reduzido
            return; // Sair imediatamente ap√≥s fechar
          }
        }
      } catch (error) {
        // Ignorar erros
      }
    }
    
    // ESC como fallback r√°pido
    try {
      await this.page.keyboard.press('Escape');
    } catch (error) {
      // Ignorar erros
    }
  }

  async clickAddLocationButtonRapido() {
    console.log('üéØ ASSERTIVO: Verificando se modal j√° est√° aberto...');
    
    // 1. PRIMEIRO: Verificar se o modal j√° est√° aberto
    const modalJaAberto = await this.page.locator('mat-dialog-container, [role="dialog"]').isVisible();
    if (modalJaAberto) {
      console.log('‚úÖ Modal j√° est√° aberto - PULANDO clique no bot√£o');
      return;
    }
    
    console.log('üéØ Modal fechado - clicando bot√£o Adicionar UMA VEZ...');
    
    // 2. SEGUNDO: Clicar UMA √öNICA VEZ no bot√£o mais espec√≠fico
    const seletorEspecifico = 'button:has-text("Adicionar Localiza√ß√£o/Visibilidade"):not([disabled])';
    
    try {
      // Aguardar elemento espec√≠fico aparecer
      await this.page.waitForSelector(seletorEspecifico, { timeout: 3000 });
      
      // Clicar UMA vez apenas
      await this.retryManager.retryClick(
          async (selector) => {
            const element = await this.page.$(selector);
            if (element) {
              await element.click();
            } else {
              throw new Error('Element not found');
            }
          },
          seletorEspecifico
        );
      console.log('‚úÖ CLIQUE √öNICO realizado no bot√£o Adicionar');
      
      // 3. TERCEIRO: Aguardar modal abrir de forma assertiva
      console.log('üéØ Aguardando modal abrir...');
      await this.page.waitForSelector('mat-dialog-container, [role="dialog"]', { timeout: 5000 });
      console.log('‚úÖ Modal CONFIRMADO aberto');
      
      return;
      
    } catch (error) {
      console.log(`‚ùå Falha no clique assertivo: ${error.message}`);
      throw new Error(`Bot√£o Adicionar n√£o encontrado: ${error.message}`);
    }
  }

  async selectOrgaoJulgadorRapido(orgao) {
    console.log(`üéØ ASSERTIVO: Sele√ß√£o direta de OJ: ${orgao}`);
    
    try {
      // 1. DIRETO: Encontrar e clicar no mat-select de √ìrg√£o Julgador
      console.log('üéØ Procurando mat-select de √ìrg√£o Julgador...');
      
      // Seletores expandidos para maior compatibilidade
      const matSelectSelectors = [
        'mat-dialog-container mat-select[placeholder="√ìrg√£o Julgador"]',
        'mat-dialog-container mat-select[placeholder="Orgao Julgador"]',
        '[role="dialog"] mat-select[placeholder="√ìrg√£o Julgador"]',
        'mat-dialog-container mat-select[name="idOrgaoJulgadorSelecionado"]',
        'mat-dialog-container mat-select[placeholder*="√ìrg√£o"]',
        '[role="dialog"] mat-select[placeholder*="√ìrg√£o"]',
        'mat-dialog-container mat-select',
        '[role="dialog"] mat-select'
      ];
      
      let matSelectElement = null;
      for (const selector of matSelectSelectors) {
        try {
          console.log(`üîç Testando seletor: ${selector}`);
          await this.page.waitForSelector(selector, { timeout: 2000 });
          matSelectElement = selector;
          console.log(`‚úÖ Mat-select encontrado: ${selector}`);
          break;
        } catch (e) {
          console.log(`‚ùå Seletor falhou: ${selector}`);
        }
      }
      
      if (!matSelectElement) {
        throw new Error('Mat-select de √ìrg√£o Julgador n√£o encontrado no modal');
      }
      
      await this.retryManager.retryClick(
          async (selector) => {
            const element = await this.page.$(selector);
            if (element) {
              await element.click();
            } else {
              throw new Error('Element not found');
            }
          },
          matSelectElement
        );
      console.log('‚úÖ Mat-select de OJ clicado');
      
      // 2. AGUARDAR: Op√ß√µes aparecerem
      console.log('üéØ Aguardando op√ß√µes do dropdown...');
      await this.page.waitForSelector('mat-option', { timeout: 3000 });
      
      // 3. SELECIONAR: Buscar op√ß√£o exata
      console.log(`üéØ Procurando op√ß√£o: ${orgao}`);
      const opcoes = this.page.locator('mat-option');
      const numOpcoes = await opcoes.count();
      
      console.log(`üìã ${numOpcoes} op√ß√µes dispon√≠veis`);
      
      let opcaoEncontrada = false;
      for (let i = 0; i < numOpcoes; i++) {
        const textoOpcao = await opcoes.nth(i).textContent();
        if (textoOpcao && textoOpcao.includes(orgao)) {
          await opcoes.nth(i).click();
          console.log(`‚úÖ OJ selecionado: ${textoOpcao.trim()}`);
          opcaoEncontrada = true;
          break;
        }
      }
      
      if (!opcaoEncontrada) {
        throw new Error(`OJ "${orgao}" n√£o encontrado nas op√ß√µes dispon√≠veis`);
      }
      
      // 4. AGUARDAR: Processamento da sele√ß√£o com delay contextual
      await this.contextualDelay('ojSelection', { priority: 'high' });
      console.log('‚úÖ Sele√ß√£o de OJ conclu√≠da');
      
    } catch (error) {
      console.error(`‚ùå Erro na sele√ß√£o assertiva de OJ: ${error.message}`);
      throw error;
    }
  }

  async configurePapelVisibilidadeRapido() {
    console.log('üéØ ASSERTIVO: Configura√ß√£o direta de papel/visibilidade...');
    
    try {
      // Verificar se o navegador ainda est√° ativo
      await this.ensureBrowserActive();
      
      // 1. PAPEL: Selecionar perfil configurado
      console.log(`üéØ Verificando campo Papel - Configurado: ${this.config.perfil || 'N√£o especificado'}`);
      console.log(`üîç [DEBUG] Config completo:`, JSON.stringify(this.config, null, 2));
      
      // Aguardar mais tempo para garantir que o modal esteja carregado
      await this.page.waitForTimeout(1500);
      
      // Verificar novamente se a p√°gina ainda est√° v√°lida
      if (this.page.isClosed()) {
        console.log('‚ö†Ô∏è [DEBUG] P√°gina foi fechada, tentando reconectar...');
        await this.reconnectBrowser();
        return;
      }
      
      // Tentar m√∫ltiplos seletores para o campo Papel
      const seletoresPapel = [
        'mat-dialog-container mat-select[placeholder*="Papel"]',
        'mat-dialog-container mat-select[formcontrolname*="papel"]',
        'mat-dialog-container mat-select[aria-label*="Papel"]',
        'mat-select[placeholder*="Papel"]',
        'mat-select:has-text("Papel")',
        '.mat-select-trigger:has-text("Papel")'
      ];
      
      let matSelectPapel = null;
      for (const seletor of seletoresPapel) {
        try {
          // Verificar se a p√°gina ainda est√° v√°lida antes de cada tentativa
          if (this.page.isClosed()) {
            console.log('‚ö†Ô∏è [DEBUG] P√°gina fechada durante busca do seletor');
            await this.reconnectBrowser();
            return;
          }
          
          console.log(`üîç [DEBUG] Testando seletor: ${seletor}`);
          const elemento = this.page.locator(seletor);
          if (await elemento.count() > 0) {
            console.log(`‚úÖ [DEBUG] Campo Papel encontrado com seletor: ${seletor}`);
            matSelectPapel = elemento;
            break;
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è [DEBUG] Erro ao testar seletor ${seletor}: ${error.message}`);
          if (error.message.includes('Target page, context or browser has been closed')) {
            console.log('üîÑ [DEBUG] Navegador fechado detectado, reconectando...');
            await this.reconnectBrowser();
            return;
          }
        }
      }
      
      if (matSelectPapel && await matSelectPapel.count() > 0) {
        console.log('üîç [DEBUG] Campo Papel encontrado, clicando...');
        
        // Verificar se a p√°gina ainda est√° v√°lida antes do clique
        if (this.page.isClosed()) {
          console.log('‚ö†Ô∏è [DEBUG] P√°gina fechada antes do clique no campo Papel');
          await this.reconnectBrowser();
          return;
        }
        
        // Tentar clicar com diferentes estrat√©gias e timeouts mais longos
        try {
          console.log('üîç [DEBUG] Tentando clique normal com timeout de 5 segundos...');
          await matSelectPapel.click({ timeout: 5000 });
          console.log('‚úÖ [DEBUG] Clique normal bem-sucedido');
        } catch (error) {
          console.log(`‚ö†Ô∏è [DEBUG] Clique normal falhou: ${error.message}`);
          if (error.message.includes('Target page, context or browser has been closed')) {
            console.log('üîÑ [DEBUG] Navegador fechado durante clique, reconectando...');
            await this.reconnectBrowser();
            return;
          }
          try {
            console.log('üîç [DEBUG] Tentando clique for√ßado...');
            await matSelectPapel.click({ force: true, timeout: 5000 });
            console.log('‚úÖ [DEBUG] Clique for√ßado bem-sucedido');
          } catch (forceError) {
            console.log(`‚ö†Ô∏è [DEBUG] Clique for√ßado falhou: ${forceError.message}`);
            if (forceError.message.includes('Target page, context or browser has been closed')) {
              console.log('üîÑ [DEBUG] Navegador fechado durante clique for√ßado, reconectando...');
              await this.reconnectBrowser();
              return;
            }
            // Tentar uma √∫ltima estrat√©gia: aguardar e tentar novamente
            console.log('üîç [DEBUG] Aguardando 2 segundos e tentando clique final...');
            await this.page.waitForTimeout(2000);
            try {
              await matSelectPapel.click({ force: true, timeout: 3000 });
              console.log('‚úÖ [DEBUG] Clique final bem-sucedido');
            } catch (finalError) {
              console.log(`‚ùå [DEBUG] Todos os cliques falharam: ${finalError.message}`);
            }
          }
        }
        
        // Verificar se a p√°gina ainda est√° v√°lida ap√≥s o clique
        if (this.page.isClosed()) {
          console.log('‚ö†Ô∏è [DEBUG] P√°gina fechada ap√≥s clique no campo Papel');
          await this.reconnectBrowser();
          return;
        }
        
        // Aguardar as op√ß√µes aparecerem com estrat√©gia mais robusta
        console.log('‚è≥ [DEBUG] Aguardando op√ß√µes do dropdown aparecerem...');
        
        try {
          // Tentar aguardar as op√ß√µes aparecerem com waitForSelector
          await this.page.waitForSelector('mat-option', { timeout: 8000 });
          console.log('‚úÖ [DEBUG] Op√ß√µes encontradas com waitForSelector');
        } catch (waitError) {
          console.log(`‚ö†Ô∏è [DEBUG] waitForSelector falhou: ${waitError.message}`);
          console.log('üîç [DEBUG] Tentando aguardar com timeout fixo...');
          await this.page.waitForTimeout(3000);
        }
        
        const opcoesPapel = this.page.locator('mat-option');
        let totalOpcoes = await opcoesPapel.count();
        console.log(`üîç [DEBUG] Total de op√ß√µes de papel dispon√≠veis: ${totalOpcoes}`);
        
        // Se ainda n√£o encontrou op√ß√µes, tentar estrat√©gias adicionais
        if (totalOpcoes === 0) {
          console.log('‚ö†Ô∏è [DEBUG] Nenhuma op√ß√£o encontrada, tentando seletores alternativos...');
          
          const seletoresAlternativos = [
            '.mat-option',
            '[role="option"]',
            '.mat-select-panel mat-option',
            'mat-select-panel mat-option'
          ];
          
          for (const seletor of seletoresAlternativos) {
            try {
              await this.page.waitForSelector(seletor, { timeout: 3000 });
              const opcoesAlt = this.page.locator(seletor);
              const totalAlt = await opcoesAlt.count();
              if (totalAlt > 0) {
                console.log(`‚úÖ [DEBUG] Op√ß√µes encontradas com seletor alternativo: ${seletor} (${totalAlt} op√ß√µes)`);
                totalOpcoes = totalAlt;
                break;
              }
            } catch (altError) {
              console.log(`‚ö†Ô∏è [DEBUG] Seletor alternativo ${seletor} falhou: ${altError.message}`);
            }
          }
          
          // √öltima tentativa com timeout longo
          if (totalOpcoes === 0) {
            console.log('‚ö†Ô∏è [DEBUG] Ainda sem op√ß√µes, aguardando mais 5 segundos...');
            await this.page.waitForTimeout(5000);
            totalOpcoes = await opcoesPapel.count();
            console.log(`üîç [DEBUG] Total final de op√ß√µes: ${totalOpcoes}`);
          }
        }
        
        // Listar todas as op√ß√µes dispon√≠veis para debug
        for (let i = 0; i < Math.min(totalOpcoes, 10); i++) {
          try {
            const opcaoTexto = await opcoesPapel.nth(i).textContent();
            console.log(`üîç [DEBUG] Op√ß√£o ${i + 1}: "${opcaoTexto?.trim()}"`);
          } catch (error) {
            console.log(`‚ö†Ô∏è [DEBUG] Erro ao ler op√ß√£o ${i + 1}: ${error.message}`);
          }
        }
        
        let perfilSelecionado = false;
        
        // Se perfil foi configurado, procurar pela op√ß√£o correta
        if (this.config.perfil && this.config.perfil.trim() !== '') {
          console.log(`üîç Procurando perfil: "${this.config.perfil}"`);
          
          // Verificar diferentes varia√ß√µes do nome do perfil
          const perfilVariacoes = [
            this.config.perfil,
            this.config.perfil.replace(/de /gi, ''),
            this.config.perfil.replace(/Secretario/gi, 'Secret√°rio'),
            this.config.perfil.replace(/Secret√°rio/gi, 'Secretario'),
            this.config.perfil.replace(/Audiencia/gi, 'Audi√™ncia'),
            this.config.perfil.replace(/Audi√™ncia/gi, 'Audiencia'),
            this.config.perfil.toLowerCase(),
            this.config.perfil.toUpperCase()
          ];
          
          console.log(`üîç [DEBUG] Varia√ß√µes do perfil a testar:`, perfilVariacoes);
          
          // Tentar encontrar o perfil exato
          for (const variacao of perfilVariacoes) {
            if (perfilSelecionado) break;
            
            console.log(`üîç [DEBUG] Testando varia√ß√£o: "${variacao}"`);
            try {
              const opcaoPerfil = opcoesPapel.filter({ hasText: new RegExp(variacao.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i') });
              const countOpcao = await opcaoPerfil.count();
              console.log(`üîç [DEBUG] Op√ß√µes encontradas para "${variacao}": ${countOpcao}`);
              
              if (countOpcao > 0) {
                const textoEncontrado = await opcaoPerfil.first().textContent();
                console.log(`üîç [DEBUG] Texto da op√ß√£o encontrada: "${textoEncontrado?.trim()}"`);
                await opcaoPerfil.first().click({ timeout: 2000 });
                console.log(`‚úÖ Papel encontrado e selecionado: ${variacao}`);
                perfilSelecionado = true;
                break;
              }
            } catch (error) {
              console.log(`‚ö†Ô∏è [DEBUG] Erro ao testar varia√ß√£o "${variacao}": ${error.message}`);
            }
          }
          
          // Se n√£o encontrou exato, procurar por palavras-chave
          if (!perfilSelecionado) {
            console.log('‚ö†Ô∏è Perfil exato n√£o encontrado, procurando por palavras-chave...');
            
            if (this.config.perfil.toLowerCase().includes('secretario') || this.config.perfil.toLowerCase().includes('secret√°rio')) {
              if (this.config.perfil.toLowerCase().includes('audiencia') || this.config.perfil.toLowerCase().includes('audi√™ncia')) {
                // Procurar "Secret√°rio de Audi√™ncia"
                console.log('üîç [DEBUG] Procurando "Secret√°rio de Audi√™ncia"...');
                const secretarioAudiencia = opcoesPapel.filter({ hasText: /Secret√°ri[oa].*Audi√™nc/i });
                const countSecretario = await secretarioAudiencia.count();
                console.log(`üîç [DEBUG] Op√ß√µes "Secret√°rio de Audi√™ncia" encontradas: ${countSecretario}`);
                
                if (countSecretario > 0) {
                  const textoSecretario = await secretarioAudiencia.first().textContent();
                  console.log(`üîç [DEBUG] Texto "Secret√°rio de Audi√™ncia": "${textoSecretario?.trim()}"`);
                  await secretarioAudiencia.first().click();
                  console.log('‚úÖ Papel: Secret√°rio de Audi√™ncia selecionado');
                  perfilSelecionado = true;
                }
              } else {
                // Procurar "Diretor de Secretaria" como fallback
                console.log('üîç [DEBUG] Procurando "Diretor de Secretaria"...');
                const diretorSecretaria = opcoesPapel.filter({ hasText: /Diretor.*Secretaria/i });
                const countDiretor = await diretorSecretaria.count();
                console.log(`üîç [DEBUG] Op√ß√µes "Diretor de Secretaria" encontradas: ${countDiretor}`);
                
                if (countDiretor > 0) {
                  const textoDiretor = await diretorSecretaria.first().textContent();
                  console.log(`üîç [DEBUG] Texto "Diretor de Secretaria": "${textoDiretor?.trim()}"`);
                  await diretorSecretaria.first().click();
                  console.log('‚úÖ Papel: Diretor de Secretaria selecionado (fallback)');
                  perfilSelecionado = true;
                }
              }
            }
            
            // Procurar especificamente por "Assessor" se for o perfil configurado
            if (!perfilSelecionado && this.config.perfil.toLowerCase().includes('assessor')) {
              console.log('üîç [DEBUG] Procurando especificamente por "Assessor"...');
              const assessorOpcao = opcoesPapel.filter({ hasText: /Assessor/i });
              const countAssessor = await assessorOpcao.count();
              console.log(`üîç [DEBUG] Op√ß√µes "Assessor" encontradas: ${countAssessor}`);
              
              if (countAssessor > 0) {
                const textoAssessor = await assessorOpcao.first().textContent();
                console.log(`üîç [DEBUG] Texto "Assessor": "${textoAssessor?.trim()}"`);
                await assessorOpcao.first().click();
                console.log('‚úÖ Papel: Assessor selecionado');
                perfilSelecionado = true;
              }
            }
          }
        }
        
        // Se ainda n√£o encontrou, tentar estrat√©gias de fallback
        if (!perfilSelecionado) {
          console.log('‚ö†Ô∏è [DEBUG] Nenhum perfil espec√≠fico encontrado, tentando fallbacks...');
          
          // Estrat√©gia 1: Procurar por palavras-chave comuns
          const palavrasChave = ['Secret√°rio', 'Secretario', 'Assessor', 'Diretor', 'Analista'];
          for (const palavra of palavrasChave) {
            if (perfilSelecionado) break;
            try {
              const opcaoChave = opcoesPapel.filter({ hasText: new RegExp(palavra, 'i') });
              if (await opcaoChave.count() > 0) {
                const textoChave = await opcaoChave.first().textContent();
                console.log(`üîç [DEBUG] Encontrado por palavra-chave "${palavra}": "${textoChave?.trim()}"`);
                await opcaoChave.first().click({ timeout: 2000 });
                console.log(`‚úÖ Papel selecionado por palavra-chave: ${palavra}`);
                perfilSelecionado = true;
                break;
              }
            } catch (error) {
              console.log(`‚ö†Ô∏è [DEBUG] Erro ao testar palavra-chave "${palavra}": ${error.message}`);
            }
          }
          
          // Estrat√©gia 2: Selecionar primeira op√ß√£o se ainda n√£o selecionou
          if (!perfilSelecionado && totalOpcoes > 0) {
            try {
              console.log('‚ö†Ô∏è [DEBUG] Selecionando primeira op√ß√£o dispon√≠vel...');
              await opcoesPapel.first().click({ timeout: 2000 });
              const textoSelecionado = await opcoesPapel.first().textContent();
              console.log(`‚úÖ Papel: Primeira op√ß√£o selecionada - "${textoSelecionado?.trim()}"`);
              perfilSelecionado = true;
            } catch (error) {
              console.log(`‚ùå [DEBUG] Erro ao selecionar primeira op√ß√£o: ${error.message}`);
            }
          }
          
          if (!perfilSelecionado) {
            console.log('‚ùå [DEBUG] Nenhuma op√ß√£o de papel p√¥de ser selecionada!');
          }
        }
      } else {
        console.log('‚ùå [DEBUG] Campo Papel n√£o encontrado com nenhum dos seletores!');
        
        // Tentar encontrar qualquer campo select no modal
        const todosSelects = this.page.locator('mat-dialog-container mat-select, mat-select');
        const totalSelects = await todosSelects.count();
        console.log(`üîç [DEBUG] Total de campos select encontrados no modal: ${totalSelects}`);
        
        for (let i = 0; i < totalSelects; i++) {
          try {
            const selectTexto = await todosSelects.nth(i).textContent();
            const placeholder = await todosSelects.nth(i).getAttribute('placeholder');
            console.log(`üîç [DEBUG] Select ${i + 1}: texto="${selectTexto?.trim()}", placeholder="${placeholder}"`);
          } catch (error) {
            console.log(`‚ö†Ô∏è [DEBUG] Erro ao analisar select ${i + 1}: ${error.message}`);
          }
        }
      }
      
      // 2. VISIBILIDADE: Selecionar "P√∫blico" rapidamente  
      console.log('üéØ Configurando Visibilidade...');
      const matSelectVisibilidade = this.page.locator('mat-dialog-container mat-select[placeholder*="Visibilidade"], mat-dialog-container mat-select[placeholder*="Localiza√ß√£o"]');
      if (await matSelectVisibilidade.count() > 0) {
        await matSelectVisibilidade.click();
        await this.page.waitForTimeout(300);
        
        // Procurar op√ß√£o "P√∫blico"
        const opcoesVisibilidade = this.page.locator('mat-option');
        const publicoOpcao = opcoesVisibilidade.filter({ hasText: /P√∫blico|Publico/i });
        
        if (await publicoOpcao.count() > 0) {
          await publicoOpcao.first().click();
          console.log('‚úÖ Visibilidade: P√∫blico selecionado');
        } else {
          await opcoesVisibilidade.first().click();
          console.log('‚úÖ Visibilidade: Primeira op√ß√£o selecionada');
        }
      }
      
      // 3. DATA INICIAL: Preencher automaticamente
      console.log('üéØ Preenchendo data inicial...');
      const dataInicialInput = this.page.locator('input[placeholder*="Data inicial"], input[name*="dataInicial"]');
      if (await dataInicialInput.count() > 0) {
        const dataAtual = new Date().toLocaleDateString('pt-BR');
        await dataInicialInput.fill(dataAtual);
        console.log(`‚úÖ Data inicial: ${dataAtual}`);
      }
      
      console.log('‚úÖ Configura√ß√£o completa em modo assertivo');
      
    } catch (error) {
      console.log(`‚ö†Ô∏è Erro na configura√ß√£o assertiva: ${error.message}`);
      // N√£o falhar - continuar com as configura√ß√µes padr√£o
    }
  }

  async saveConfigurationRapido() {
    console.log('üéØ ASSERTIVO: Salvamento direto...');
    
    try {
      // 1. DIRETO: Bot√£o Gravar mais espec√≠fico
      console.log('üéØ Procurando bot√£o Gravar...');
      const botaoGravar = 'mat-dialog-container button:has-text("Gravar"):not([disabled])';
      
      // Debug: listar todos os bot√µes dispon√≠veis
      const todosBotoes = await this.page.locator('mat-dialog-container button').all();
      console.log(`üîç [DEBUG] Total de bot√µes no modal: ${todosBotoes.length}`);
      
      for (let i = 0; i < todosBotoes.length; i++) {
        const botaoTexto = await todosBotoes[i].textContent();
        const botaoDisabled = await todosBotoes[i].isDisabled();
        console.log(`üîç [DEBUG] Bot√£o ${i + 1}: "${botaoTexto?.trim()}" (disabled: ${botaoDisabled})`);
      }
      
      console.log(`üîç [DEBUG] Aguardando seletor: ${botaoGravar}`);
      await this.page.waitForSelector(botaoGravar, { timeout: 3000 });
      console.log('üîç [DEBUG] Seletor encontrado, executando clique...');
      
      await this.retryManager.retryPJEOperation(
        async () => {
          const element = await this.page.$(botaoGravar);
          if (element) {
            console.log('üîç [DEBUG] Elemento encontrado, clicando...');
            await element.click();
            console.log('üîç [DEBUG] Clique executado com sucesso');
          } else {
            throw new Error('Save button not found');
          }
        },
        'saveConfiguration'
      );
      console.log('‚úÖ CLIQUE no bot√£o Gravar realizado');
      
      // 2. AGUARDAR: Modal fechar ou sucesso
      console.log('üéØ Aguardando processamento...');
      
      // Aguardar uma das condi√ß√µes: modal fechar OU mensagem de sucesso
      await Promise.race([
        this.page.waitForSelector('mat-dialog-container', { state: 'detached', timeout: 5000 }),
        this.page.waitForSelector(':has-text("sucesso"), :has-text("salvo"), :has-text("cadastrado")', { timeout: 5000 })
      ]);
      
      console.log('‚úÖ Salvamento confirmado');
      
    } catch (error) {
      console.log(`‚ö†Ô∏è Erro no salvamento assertivo: ${error.message}`);
      console.log(`üîç [DEBUG] Stack trace:`, error.stack);
      
      // Fallback: tentar outros bot√µes
      const fallbackSelectors = [
        '[role="dialog"] button:has-text("Gravar")',
        'button:has-text("Salvar")',
        'button:has-text("Confirmar")',
        'mat-dialog-container button[type="submit"]',
        'mat-dialog-container button:not([disabled])'
      ];
      
      console.log('üîç [DEBUG] Tentando fallback selectors...');
      for (const selector of fallbackSelectors) {
        try {
          console.log(`üîç [DEBUG] Testando selector: ${selector}`);
          const botao = this.page.locator(selector);
          const count = await botao.count();
          console.log(`üîç [DEBUG] Elementos encontrados para "${selector}": ${count}`);
          
          if (count > 0) {
            const textoFallback = await botao.first().textContent();
            console.log(`üîç [DEBUG] Texto do bot√£o fallback: "${textoFallback?.trim()}"`);
            await botao.first().click();
            console.log(`‚úÖ Fallback: ${selector} clicado`);
            return;
          }
        } catch (fallbackError) {
          console.log(`üîç [DEBUG] Erro no fallback "${selector}": ${fallbackError.message}`);
          continue;
        }
      }
      
      throw new Error('Nenhum bot√£o de salvamento encontrado');
    }
  }

  async verifySuccessRapido() {
    console.log('üéØ ASSERTIVO: Verifica√ß√£o instant√¢nea de sucesso...');
    
    // Verifica√ß√£o r√°pida sem timeout desnecess√°rio
    try {
      // 1. Verificar se modal fechou (indicativo de sucesso)
      const modalAberto = await this.page.locator('mat-dialog-container').isVisible();
      if (!modalAberto) {
        console.log('‚úÖ Modal fechou - opera√ß√£o CONFIRMADA como bem-sucedida');
        return true;
      }
      
      // 2. Se modal ainda aberto, verificar mensagens rapidamente
      const mensagemSucesso = await this.page.locator(':has-text("sucesso"), :has-text("cadastrado"), :has-text("salvo")').count();
      if (mensagemSucesso > 0) {
        console.log('‚úÖ Mensagem de sucesso detectada');
        return true;
      }
      
      // 3. Se chegou aqui, assumir sucesso (modal pode estar processando)
      console.log('‚ÑπÔ∏è Modal ainda aberto - assumindo processamento em andamento');
      return true;
      
    } catch (error) {
      console.log(`‚ö†Ô∏è Erro na verifica√ß√£o: ${error.message} - assumindo sucesso`);
      return true; // Assumir sucesso para n√£o quebrar fluxo
    }
  }

  // === FUN√á√ïES ORIGINAIS (MANTIDAS PARA COMPATIBILIDADE) ===

  async stabilizePage() {
    // Aguardar estabiliza√ß√£o da p√°gina
    await this.page.waitForTimeout(1500);
        
    // Aguardar que n√£o haja requisi√ß√µes de rede por 500ms
    try {
      await this.page.waitForLoadState('networkidle', { timeout: 5000 });
    } catch (error) {
      console.log('Timeout aguardando networkidle, continuando...');
    }
  }

  async closeAnyModals() {
    console.log('üßπ Procurando modais/overlays para fechar...');
    
    // Seletores priorit√°rios com timeout reduzido
    const prioritySelectors = [
      '.mat-dialog-actions button',
      '.mat-overlay-backdrop',
      '.cdk-overlay-backdrop',
      'button:has-text("OK")',
      'button:has-text("Fechar")',
      '.modal-backdrop'
    ];
    
    let modalsFound = 0;
    
    // Primeira passada: seletores priorit√°rios com timeout muito baixo
    for (const selector of prioritySelectors) {
      try {
        // Usar timeout muito baixo (100ms) para n√£o travar
        const elements = await this.page.$$(selector);
        
        for (const element of elements) {
          try {
            const isVisible = await element.isVisible();
            if (isVisible) {
              await element.click();
              modalsFound++;
              console.log(`‚úÖ Fechou modal/overlay: ${selector}`);
              await this.delay(100); // Delay reduzido
              return; // Sair ap√≥s fechar o primeiro modal
            }
          } catch (clickError) {
            // Ignorar erros de clique
          }
        }
      } catch (error) {
        // Ignorar erros de seletores n√£o encontrados
      }
    }
    
    // Se n√£o encontrou modais priorit√°rios, tentar ESC rapidamente
    try {
      await this.page.keyboard.press('Escape');
      await this.delay(300);
      console.log('üîë Pressionou ESC para fechar modais');
    } catch (escError) {
      console.log('‚ö†Ô∏è Erro ao pressionar ESC:', escError.message);
    }
    
    if (modalsFound > 0) {
      console.log(`‚úÖ Total de modais/overlays fechados: ${modalsFound}`);
    } else {
      console.log('‚ÑπÔ∏è Nenhum modal/overlay encontrado');
    }
  }

  async clickAddLocationButton() {
    console.log('üîÑ INICIANDO clickAddLocationButton');
    const addButtonSelectors = [
      'button:has-text("Adicionar Localiza√ß√£o/Visibilidade"):not([disabled])',
      'button:has-text("Adicionar Localiza√ß√£o"):not([disabled])',
      'button:has-text("Adicionar"):not([disabled]):visible',
      'button .mat-button-wrapper:has-text("Adicionar"):not([disabled])',
      'input[value*="Adicionar"]:not([disabled])'
    ];
        
    let addButton = null;
        
    for (const selector of addButtonSelectors) {
      try {
        console.log(`üîç Testando seletor: ${selector}`);
        await this.page.waitForSelector(selector, { timeout: 3000 });
        addButton = selector;
        console.log(`‚úÖ Bot√£o Adicionar encontrado: ${selector}`);
        break;
      } catch (error) {
        console.log(`‚ùå Seletor ${selector} n√£o encontrado: ${error.message}`);
      }
    }
        
    if (!addButton) {
      console.log('‚ùå ERRO: Nenhum bot√£o Adicionar encontrado');
      throw new Error('Bot√£o "Adicionar Localiza√ß√£o/Visibilidade" n√£o encontrado');
    }
        
    console.log(`üñ±Ô∏è Clicando no bot√£o: ${addButton}`);
    await this.page.click(addButton);
    await this.delay(2000);
    console.log('‚úÖ clickAddLocationButton conclu√≠do');
  }

  async selectOrgaoJulgador(orgao) {
    // Implementar sele√ß√£o do √≥rg√£o julgador usando a vers√£o melhorada
    // com estrat√©gia aprimorada para mat-select do Angular Material
        
    console.log(`üîÑ INICIANDO selectOrgaoJulgador para: ${orgao}`);
    this.sendStatus('info', 'Selecionando √≥rg√£o julgador...', null, orgao);
        
    // Usar a fun√ß√£o melhorada com estrat√©gia de trigger
    const { vincularOJMelhorado } = require('../vincularOJ.js');
    console.log(`üîÑ Chamando vincularOJMelhorado para: ${orgao} com perfil: ${this.config.perfil || 'N√£o especificado'}`);
    await vincularOJMelhorado(
      this.page, 
      orgao, // Nome do √≥rg√£o como string
      this.config.perfil || 'Assessor', // Usar perfil configurado
      'P√∫blico'
    );
    console.log(`‚úÖ vincularOJMelhorado conclu√≠do para: ${orgao}`);
  }

  async configurePapelVisibilidade() {
    // Configurar papel e visibilidade se necess√°rio
    // Esta l√≥gica seria implementada baseada nos requisitos espec√≠ficos
    await this.delay(500);
  }

  async saveConfiguration() {
    // Salvar configura√ß√£o
    // Esta l√≥gica seria similar ao que j√° existe no vincularOJ.js
    await this.delay(500);
  }

  async verifySuccess() {
    // Verificar se a opera√ß√£o foi bem-sucedida
    // Implementar verifica√ß√µes de sucesso
    await this.delay(500);
  }

  async processOrgaosJulgadoresWithServerTracking(servidor) {
    console.log(`üéØ [DEBUG] INICIANDO processOrgaosJulgadoresWithServerTracking para ${servidor.nome}`);
    console.log(`üéØ [DEBUG] CPF: ${servidor.cpf}, Perfil: ${servidor.perfil}, OJs: ${servidor.orgaos?.length || 0}`);
    
    const serverResult = this.servidorResults[servidor.cpf];
    if (!serverResult) {
      console.error(`‚ùå [ERROR] serverResult n√£o encontrado para CPF ${servidor.cpf}`);
      throw new Error(`Resultado do servidor n√£o encontrado para CPF ${servidor.cpf}`);
    }
    
    this.sendStatus('info', `üîç Verificando OJs cadastrados para ${servidor.nome}...`, null, 'Otimizando processo');
    
    // IMPORTANTE: Sempre limpar cache no in√≠cio de cada servidor
    console.log(`üóëÔ∏è [DEBUG] Limpando cache de OJs antes de processar ${servidor.nome}...`);
    this.ojCache.clear();
    console.log('‚úÖ [DEBUG] Cache limpo - come√ßando fresh para este servidor');
    
    // Verificar OJs j√° cadastrados em lote (otimiza√ß√£o com cache)
    console.log(`üîç [DEBUG] Carregando OJs existentes para ${servidor.nome}...`);
    await this.loadExistingOJs();
    console.log(`üîç [DEBUG] Cache de OJs carregado: ${this.ojCache.size} OJs em cache`);
        
    // Normalizar e filtrar OJs que precisam ser processados
    console.log(`üîç [DEBUG] this.config.orgaos: ${JSON.stringify(this.config.orgaos?.slice(0,3) || [])}${this.config.orgaos?.length > 3 ? '...' : ''}`);
    const ojsNormalizados = this.config.orgaos.map(orgao => this.normalizeOrgaoName(orgao));
    console.log(`üîç [DEBUG] OJs normalizados: ${JSON.stringify(ojsNormalizados.slice(0,3))}${ojsNormalizados.length > 3 ? '...' : ''}`);
    
    const ojsToProcess = ojsNormalizados.filter(orgao => !this.ojCache.has(orgao));
    console.log(`üîç [DEBUG] OJs a processar (ap√≥s filtro cache): ${JSON.stringify(ojsToProcess.slice(0,3))}${ojsToProcess.length > 3 ? '...' : ''}`);
        
    this.sendStatus('info', `‚ö° ${ojsToProcess.length} novos OJs | ${this.ojCache.size} j√° cadastrados`, null, `Servidor: ${servidor.nome}`);
    
    if (ojsToProcess.length === 0) {
      console.log('üîç [DEBUG] NENHUM OJ para processar - todos j√° est√£o em cache');
      return;
    }
        
    // Processar cada OJ restante com tracking
    console.log(`üîç [DEBUG] INICIANDO loop de processamento de ${ojsToProcess.length} OJs`);
    for (let i = 0; i < ojsToProcess.length; i++) {
      const orgao = ojsToProcess[i];
      console.log(`üîç [DEBUG] Processando OJ ${i + 1}/${ojsToProcess.length}: ${orgao}`);
      serverResult.ojsProcessados++;
      
      this.sendStatus('info', `[${servidor.nome}] OJ ${i + 1}/${ojsToProcess.length}: ${orgao}`, null, 'Processando vincula√ß√£o');
            
      try {
        const startOJ = Date.now();
        await this.processOrgaoJulgador(orgao);
        const timeOJ = Date.now() - startOJ;
        
        serverResult.sucessos++;
        serverResult.detalhes.push({
          orgao,
          status: 'Inclu√≠do com Sucesso',
          tempo: timeOJ,
          perfil: this.config.perfil,
          timestamp: new Date().toISOString()
        });
        
        this.results.push({
          servidor: servidor.nome,
          orgao,
          status: 'Inclu√≠do com Sucesso',
          erro: null,
          perfil: this.config.perfil,
          cpf: this.config.cpf,
          timestamp: new Date().toISOString()
        });
        
      } catch (error) {
        console.error(`‚ùå Erro OJ ${orgao} (${servidor.nome}):`, error.message);
        
        serverResult.erros++;
        serverResult.detalhes.push({
          orgao,
          status: 'Erro',
          erro: error.message,
          timestamp: new Date().toISOString()
        });
        
        this.results.push({
          servidor: servidor.nome,
          orgao,
          status: 'Erro',
          erro: error.message,
          cpf: this.config.cpf,
          timestamp: new Date().toISOString()
        });
                
        // Recupera√ß√£o r√°pida sem interromper processamento
        await this.quickErrorRecovery();
      }
            
      // Pausa ultra-otimizada entre OJs (25ms para velocidade m√°xima)
      await this.delay(25);
    }
        
    // Adicionar OJs j√° existentes ao relat√≥rio do servidor
    for (const orgaoExistente of this.ojCache) {
      if (this.config.orgaos.includes(orgaoExistente)) {
        serverResult.jaIncluidos++;
        serverResult.detalhes.push({
          orgao: orgaoExistente,
          status: 'J√° Inclu√≠do',
          perfil: this.config.perfil,
          timestamp: new Date().toISOString()
        });
        
        this.results.push({
          servidor: servidor.nome,
          orgao: orgaoExistente,
          status: 'J√° Inclu√≠do',
          erro: null,
          perfil: this.config.perfil,
          cpf: this.config.cpf,
          timestamp: new Date().toISOString()
        });
      }
    }
  }

  async quickErrorRecovery() {
    console.log('‚ö° Recupera√ß√£o r√°pida ap√≥s erro...');
    
    try {
      // Fechar modais rapidamente
      await Promise.race([
        this.closeAnyModalsRapido(),
        this.delay(1000)
      ]);
      
      // Escape como √∫ltimo recurso
      await this.page.keyboard.press('Escape');
      await this.delay(300);
      
    } catch (error) {
      console.log('‚ö†Ô∏è Erro na recupera√ß√£o r√°pida:', error.message);
    }
  }

  async attemptErrorRecovery() {
    console.log('üîß Tentando recupera√ß√£o autom√°tica...');
    
    try {
      // Aguardar estabiliza√ß√£o m√≠nima
      await this.delay(2000);
      
      // Tentar fechar modais de erro
      await this.closeAnyModals();
      
      // Tentar navegar para uma p√°gina est√°vel
      await Promise.race([
        this.navigationOptimizer.fastNavigate(this.page, 'https://pje.trt15.jus.br/pjekz/pessoa-fisica'),
        this.delay(5000)
      ]);
      
      console.log('‚úÖ Recupera√ß√£o autom√°tica conclu√≠da');
      
    } catch (error) {
      console.log('‚ö†Ô∏è Falha na recupera√ß√£o autom√°tica:', error.message);
    }
  }

  async ensureCleanState() {
    console.log('üßπ Garantindo estado limpo do navegador...');
    
    try {
      // Fechar quaisquer modais ou popups abertos
      await this.closeAnyModals();
      
      // Aguardar estabiliza√ß√£o
      await this.delay(500);
      
      // Verificar se ainda est√° na p√°gina correta
      const currentUrl = this.page.url();
      console.log(`üîç URL atual antes da limpeza: ${currentUrl}`);
      
      // Se n√£o estiver na p√°gina de pessoas, navegar para ela
      if (!currentUrl.includes('pessoa-fisica')) {
        console.log('üîÑ Navegando de volta para p√°gina de pessoas...');
        await this.navigationOptimizer.fastNavigate(this.page, 'https://pje.trt15.jus.br/pjekz/pessoa-fisica');
        await this.delay(1000);
      }
      
      console.log('‚úÖ Estado limpo garantido');
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro ao garantir estado limpo:', error.message);
      // N√£o propagar o erro, apenas log
    }
  }

  async performRobustRecovery() {
    console.log('üõ†Ô∏è Executando recupera√ß√£o robusta...');
    
    try {
      // Verificar se o navegador ainda est√° ativo
      if (!this.page || this.page.isClosed()) {
        console.log('üîÑ Navegador fechado detectado, reconectando...');
        await this.reconnectBrowser();
        return;
      }
      
      // Aguardar estabiliza√ß√£o extendida
      await this.delay(3000);
      
      // M√∫ltiplas tentativas de fechamento de modais
      for (let i = 0; i < 3; i++) {
        await this.closeAnyModals();
        await this.delay(500);
      }
      
      // Navegar para p√°gina base e aguardar carregamento completo
      const baseUrl = 'https://pje.trt15.jus.br/pjekz/pessoa-fisica';
      
      console.log(`üîÑ Navegando para p√°gina base: ${baseUrl}`);
      await this.navigationOptimizer.optimizedNavigate(this.page, baseUrl);
      
      // Aguardar p√°gina estabilizar completamente
      await Promise.race([
        this.page.waitForSelector('table', { timeout: 10000 }),
        this.page.waitForSelector('.datatable', { timeout: 10000 }),
        this.delay(5000) // Fallback
      ]);
      
      // Aguardar estabiliza√ß√£o final
      await this.delay(2000);
      
      console.log('‚úÖ Recupera√ß√£o robusta conclu√≠da');
      
    } catch (error) {
      console.error('‚ùå Falha na recupera√ß√£o robusta:', error.message);
      
      // Verificar se o erro √© devido ao navegador fechado
      if (error.message.includes('Target page, context or browser has been closed') || 
          error.message.includes('Session closed') ||
          error.message.includes('Connection closed')) {
        console.log('üîÑ Erro de conex√£o detectado, reconectando navegador...');
        await this.reconnectBrowser();
        return;
      }
      
      // Tentar recupera√ß√£o b√°sica como √∫ltimo recurso
      try {
        await this.delay(5000);
        await this.page.reload({ waitUntil: 'domcontentloaded', timeout: 20000 });
        await this.delay(2000);
        console.log('‚úÖ Recupera√ß√£o b√°sica (reload) executada');
      } catch (reloadError) {
        console.error('üí• Falha total na recupera√ß√£o:', reloadError.message);
        if (reloadError.message.includes('Target page, context or browser has been closed')) {
          await this.reconnectBrowser();
        }
      }
    }
  }

  async reconnectBrowser() {
    console.log('üîå Reconectando navegador...');
    
    try {
      // Fechar conex√µes antigas se ainda existirem
      if (this.browser && !this.browser.contexts().length === 0) {
        try {
          await this.browser.close();
        } catch (e) {
          console.log('‚ö†Ô∏è Erro ao fechar navegador antigo:', e.message);
        }
      }
      
      // Aguardar antes de reconectar
      await this.delay(2000);
      
      // Reinicializar navegador
      await this.initializeBrowser();
      
      // Realizar login novamente
      await this.performLogin();
      
      console.log('‚úÖ Navegador reconectado com sucesso');
      
    } catch (error) {
      console.error('‚ùå Falha na reconex√£o do navegador:', error.message);
      throw new Error(`Falha cr√≠tica na reconex√£o do navegador: ${error.message}`);
    }
  }

  async ensureBrowserActive() {
    if (!this.page || this.page.isClosed()) {
      console.log('üîÑ P√°gina fechada detectada, reconectando...');
      await this.reconnectBrowser();
    }
  }

  async handleErrorRecovery() {
    console.log('Iniciando recupera√ß√£o ap√≥s erro...');
        
    // Aguardar estabiliza√ß√£o
    await this.delay(3000);
        
    // Tentar fechar modais de erro
    await this.closeAnyModals();
        
    // Tentar pressionar Escape como √∫ltimo recurso
    try {
      await this.page.keyboard.press('Escape');
      await this.delay(1000);
    } catch (error) {
      console.log('Erro ao pressionar Escape:', error.message);
    }
  }

  // M√©todo para otimizar resultados removendo duplicatas e melhorando informa√ß√µes
  otimizarResultados() {
    console.log('üîÑ Otimizando resultados do relat√≥rio...');
    
    // Mapa para agrupar por √≥rg√£o julgador
    const orgaosMap = new Map();
    
    // Processar cada resultado
    this.results.forEach(resultado => {
      const orgao = resultado.orgao;
      
      if (!orgaosMap.has(orgao)) {
        // Primeiro registro para este √≥rg√£o
        let statusFinal = resultado.status;
        let observacoes = resultado.erro || '';
        
        // Normalizar status
        if (statusFinal === 'Sucesso' || statusFinal === 'J√° Inclu√≠do') {
          statusFinal = 'Inclu√≠do com Sucesso';
          // Adicionar perfil nas observa√ß√µes (usar perfil do resultado se dispon√≠vel)
          observacoes = resultado.perfil || this.config.perfil || 'Perfil n√£o especificado';
        }
        
        orgaosMap.set(orgao, {
          orgao,
          status: statusFinal,
          observacoes,
          timestamp: resultado.timestamp
        });
      } else {
        // J√° existe registro para este √≥rg√£o - priorizar sucesso
        const existente = orgaosMap.get(orgao);
        
        if (resultado.status === 'Sucesso' && existente.status !== 'Inclu√≠do com Sucesso') {
          // Atualizar para sucesso se ainda n√£o estava
          existente.status = 'Inclu√≠do com Sucesso';
          existente.observacoes = resultado.perfil || this.config.perfil || 'Perfil n√£o especificado';
          existente.timestamp = resultado.timestamp;
        } else if (resultado.status === 'J√° Inclu√≠do' && existente.status === 'Erro') {
          // Se teve erro antes mas agora est√° inclu√≠do, atualizar
          existente.status = 'Inclu√≠do com Sucesso';
          existente.observacoes = resultado.perfil || this.config.perfil || 'Perfil n√£o especificado';
          existente.timestamp = resultado.timestamp;
        }
        // Ignorar duplicatas de "J√° Inclu√≠do" ou outros casos
      }
    });
    
    // Converter mapa para array
    const resultadosFinais = Array.from(orgaosMap.values());
    
    console.log(`‚úÖ Resultados otimizados: ${this.results.length} ‚Üí ${resultadosFinais.length} (${this.results.length - resultadosFinais.length} duplicatas removidas)`);
    
    return resultadosFinais;
  }

  async generateMultiServerReport() {
    this.sendStatus('info', 'üìä Gerando relat√≥rio consolidado...', 95, 'Finalizando processamento de m√∫ltiplos servidores');
        
    // Configurar diret√≥rio de sa√≠da
    const outputDir = path.join(__dirname, '..', '..', 'data');        
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Calcular estat√≠sticas globais
    const totalServidores = this.processedServidores;
    const servidoresBemSucedidos = this.successfulServidores;
    const servidoresComFalha = this.failedServidores;
    
    let totalOJsProcessados = 0;
    let totalSucessos = 0;
    let totalErros = 0;
    let totalJaIncluidos = 0;
    
    // Preparar dados detalhados por servidor
    const servidoresDetalhados = [];
    
    Object.values(this.servidorResults).forEach(server => {
      totalOJsProcessados += server.ojsProcessados;
      totalSucessos += server.sucessos;
      totalErros += server.erros;
      totalJaIncluidos += server.jaIncluidos;
      
      servidoresDetalhados.push({
        nome: server.nome,
        cpf: server.cpf,
        perfil: server.perfil,
        status: server.status,
        tentativas: {
          realizadas: server.tentativas || 0,
          maximas: server.maxTentativas || 2,
          recuperacoes: server.tentativas > 1 ? server.tentativas - 1 : 0
        },
        estatisticas: {
          totalOJs: server.totalOJs,
          ojsProcessados: server.ojsProcessados,
          sucessos: server.sucessos,
          erros: server.erros,
          jaIncluidos: server.jaIncluidos,
          percentualSucesso: server.ojsProcessados > 0 ? 
            parseFloat(((server.sucessos / server.ojsProcessados) * 100).toFixed(1)) : 0
        },
        tempo: {
          inicioProcessamento: server.inicioProcessamento,
          fimProcessamento: server.fimProcessamento,
          tempoProcessamento: server.tempoProcessamento,
          tempoProcessamentoFormatado: server.tempoProcessamento ? 
            `${(server.tempoProcessamento/1000).toFixed(1)}s` : 'N/A'
        },
        detalhesOJs: server.detalhes,
        erroGeral: server.erroGeral || null
      });
    });
    
    // Relat√≥rio consolidado
    const relatorioConsolidado = {
      timestamp: new Date().toISOString(),
      tipoRelatorio: 'M√∫ltiplos Servidores',
      resumoGeral: {
        totalServidores,
        servidoresBemSucedidos,
        servidoresComFalha,
        errosConsecutivosMaximos: this.consecutiveErrors || 0,
        percentualServidoresSucesso: totalServidores > 0 ? 
          parseFloat(((servidoresBemSucedidos / totalServidores) * 100).toFixed(1)) : 0,
        totalOJsProcessados,
        totalSucessos,
        totalErros,
        totalJaIncluidos,
        percentualOJsSucesso: totalOJsProcessados > 0 ? 
          parseFloat(((totalSucessos / totalOJsProcessados) * 100).toFixed(1)) : 0,
        processamentoSequencial: {
          tentativasTotal: servidoresDetalhados.reduce((acc, s) => acc + (s.tentativas.realizadas || 0), 0),
          recuperacoesTotal: servidoresDetalhados.reduce((acc, s) => acc + s.tentativas.recuperacoes, 0),
          servidoresComRecuperacao: servidoresDetalhados.filter(s => s.tentativas.recuperacoes > 0).length,
          eficienciaProcessamento: totalServidores > 0 ? 
            parseFloat(((servidoresBemSucedidos / (servidoresDetalhados.reduce((acc, s) => acc + s.tentativas.realizadas, 0))) * 100).toFixed(1)) : 0
        }
      },
      servidores: servidoresDetalhados,
      resultadosDetalhados: this.results,
      estatisticasAvancadas: {
        tempoMedioProcessamentoServidor: servidoresDetalhados.length > 0 ? 
          servidoresDetalhados
            .filter(s => s.tempo.tempoProcessamento)
            .reduce((acc, s) => acc + s.tempo.tempoProcessamento, 0) / 
          servidoresDetalhados.filter(s => s.tempo.tempoProcessamento).length : 0,
        servidorMaisRapido: servidoresDetalhados
          .filter(s => s.tempo.tempoProcessamento && s.status === 'Conclu√≠do')
          .reduce((min, s) => !min || s.tempo.tempoProcessamento < min.tempo.tempoProcessamento ? s : min, null),
        servidorMaisLento: servidoresDetalhados
          .filter(s => s.tempo.tempoProcessamento && s.status === 'Conclu√≠do')
          .reduce((max, s) => !max || s.tempo.tempoProcessamento > max.tempo.tempoProcessamento ? s : max, null)
      }
    };
        
    // Salvar relat√≥rio JSON
    const timestamp = Date.now();
    const jsonPath = path.join(outputDir, `relatorio-multi-servidor-${timestamp}.json`);
    fs.writeFileSync(jsonPath, JSON.stringify(relatorioConsolidado, null, 2));
        
    // Gerar CSV consolidado
    const csvHeaders = [
      'Servidor',
      'CPF',
      'Perfil',
      'Status',
      'Total OJs',
      'Sucessos',
      'Erros',
      'J√° Inclu√≠dos',
      '% Sucesso',
      'Tempo (s)',
      'Erro Geral'
    ];
    
    const csvRows = servidoresDetalhados.map(server => [
      `"${server.nome}"`,
      `"${server.cpf}"`,
      `"${server.perfil}"`,
      `"${server.status}"`,
      server.estatisticas.totalOJs,
      server.estatisticas.sucessos,
      server.estatisticas.erros,
      server.estatisticas.jaIncluidos,
      `${server.estatisticas.percentualSucesso}%`,
      server.tempo.tempoProcessamentoFormatado,
      `"${server.erroGeral || ''}"`
    ].join(','));
    
    const csvContent = [csvHeaders.join(','), ...csvRows].join('\n');
    const csvPath = path.join(outputDir, `relatorio-multi-servidor-${timestamp}.csv`);
    fs.writeFileSync(csvPath, csvContent);
    
    // Gerar relat√≥rio detalhado por OJ
    const csvOJHeaders = [
      'Servidor',
      'CPF Servidor', 
      '√ìrg√£o Julgador',
      'Status',
      'Perfil',
      'Erro',
      'Tempo (ms)',
      'Timestamp'
    ];
    
    const csvOJRows = [];
    servidoresDetalhados.forEach(server => {
      server.detalhesOJs.forEach(oj => {
        csvOJRows.push([
          `"${server.nome}"`,
          `"${server.cpf}"`,
          `"${oj.orgao}"`,
          `"${oj.status}"`,
          `"${oj.perfil || server.perfil}"`,
          `"${oj.erro || ''}"`,
          oj.tempo || '',
          `"${oj.timestamp}"`
        ].join(','));
      });
    });
    
    const csvOJContent = [csvOJHeaders.join(','), ...csvOJRows].join('\n');
    const csvOJPath = path.join(outputDir, `relatorio-detalhado-ojs-${timestamp}.csv`);
    fs.writeFileSync(csvOJPath, csvOJContent);
        
    console.log(`üìÑ Relat√≥rio JSON consolidado: ${jsonPath}`);
    console.log(`üìÑ Relat√≥rio CSV servidores: ${csvPath}`);
    console.log(`üìÑ Relat√≥rio CSV detalhado OJs: ${csvOJPath}`);
        
    // Imprimir resultado final
    console.log('=== RESULTADO FINAL M√öLTIPLOS SERVIDORES ===');
    console.log(JSON.stringify(relatorioConsolidado, null, 2));
    console.log('=== FIM RESULTADO ===');
        
    // Calcular estat√≠sticas de recupera√ß√£o
    const totalRecuperacoes = servidoresDetalhados.reduce((acc, s) => acc + s.tentativas.recuperacoes, 0);
    const servidoresComRecuperacao = servidoresDetalhados.filter(s => s.tentativas.recuperacoes > 0).length;
    
    this.sendStatus('success', `üéâ Processamento SEQUENCIAL conclu√≠do: ${servidoresBemSucedidos}/${totalServidores} servidores | ${totalSucessos} sucessos`, 100, 
      `${totalErros} erros | ${totalJaIncluidos} j√° inclu√≠dos | ${totalRecuperacoes} recupera√ß√µes realizadas em ${servidoresComRecuperacao} servidores`);
  }

  async generateReport() {
    this.sendStatus('info', 'Gerando relat√≥rio...', 95, 'Finalizando processo');
        
    // Configurar diret√≥rio de sa√≠da
    const outputDir = path.join(__dirname, '..', '..', 'data');
        
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // OTIMIZAR RESULTADOS: Remover duplicatas e melhorar informa√ß√µes
    const resultadosOtimizados = this.otimizarResultados();
        
    // Calcular estat√≠sticas baseadas nos resultados otimizados
    const sucessos = resultadosOtimizados.filter(r => r.status === 'Inclu√≠do com Sucesso').length;
    const erros = resultadosOtimizados.filter(r => r.status === 'Erro').length;
    const totalValidos = sucessos + erros;
        
    // Gerar relat√≥rio JSON detalhado com resultados otimizados
    const jsonReport = {
      timestamp: new Date().toISOString(),
      config: {
        cpf: this.config.cpf,
        perfil: this.config.perfil,
        totalOrgaos: this.config.orgaos.length
      },
      results: resultadosOtimizados, // Usar resultados otimizados
      summary: {
        total: resultadosOtimizados.length,
        sucessos,
        erros,
        totalValidos,
        estatisticas: totalValidos > 0 ? {
          percentualSucesso: parseFloat(((sucessos / totalValidos) * 100).toFixed(1)),
          percentualErros: parseFloat(((erros / totalValidos) * 100).toFixed(1))
        } : null
      },
      detalhes: {
        orgaosIncluidos: resultadosOtimizados.filter(r => r.status === 'Inclu√≠do com Sucesso').map(r => ({
          orgao: r.orgao,
          perfil: r.observacoes
        })),
        orgaosComErro: resultadosOtimizados.filter(r => r.status === 'Erro').map(r => ({
          orgao: r.orgao,
          erro: r.observacoes || 'Erro n√£o especificado'
        }))
      }
    };
        
    // Salvar relat√≥rio
    const jsonPath = path.join(outputDir, `relatorio-servidor-${Date.now()}.json`);
    fs.writeFileSync(jsonPath, JSON.stringify(jsonReport, null, 2));
        
    // Gerar CSV otimizado
    const csvContent = [
      '√ìrg√£o Julgador,Status,Observa√ß√µes',
      ...resultadosOtimizados.map(r => `"${r.orgao}","${r.status}","${r.observacoes || ''}"`)
    ].join('\n');
        
    const csvPath = path.join(outputDir, `relatorio-servidor-${Date.now()}.csv`);
    fs.writeFileSync(csvPath, csvContent);
        
    console.log(`üìÑ Relat√≥rio JSON salvo em: ${jsonPath}`);
    console.log(`üìÑ Relat√≥rio CSV salvo em: ${csvPath}`);
        
    // Imprimir resultado final em formato JSON para ser capturado pelo servidor
    console.log('=== RESULTADO FINAL ===');
    console.log(JSON.stringify(jsonReport, null, 2));
    console.log('=== FIM RESULTADO ===');
        
    this.sendStatus('success', 'Relat√≥rio gerado', 98, `${sucessos} sucessos, ${erros} erros`);
  }

  async cleanup() {
    try {
      // Parar monitoramento de performance
      if (this.performanceMonitor) {
        this.performanceMonitor.stopMonitoring();
      }
      
      if (this.page && !this.page.isClosed()) {
        if (this.isProduction) {
          await this.page.close();
        } else {
          console.log('Mantendo p√°gina aberta para desenvolvimento');
        }
      }
            
      if (this.browser && this.isProduction) {
        await this.browser.close();
      }
    } catch (error) {
      console.error('Erro durante cleanup:', error);
    }
  }



  async stopAutomation() {
    this.isRunning = false;
    await this.cleanup();
  }

  getRelatorio() {
    // Usar resultados otimizados para o relat√≥rio da interface
    const resultadosOtimizados = this.otimizarResultados();
    
    // Calcular estat√≠sticas baseadas nos resultados otimizados
    const sucessos = resultadosOtimizados.filter(r => r.status === 'Inclu√≠do com Sucesso').length;
    const erros = resultadosOtimizados.filter(r => r.status === 'Erro').length;
    const totalValidos = sucessos + erros;
        
    // Retornar relat√≥rio otimizado no formato esperado pelo frontend
    return {
      timestamp: new Date().toISOString(),
      config: {
        cpf: this.config?.cpf || '',
        perfil: this.config?.perfil || '',
        totalOrgaos: this.config?.orgaos?.length || 0
      },
      resultados: resultadosOtimizados.map(r => ({
        orgao: r.orgao,
        status: r.status,
        observacoes: r.observacoes || '-'
      })),
      resumo: {
        total: resultadosOtimizados.length,
        sucessos,
        erros,
        totalValidos,
        percentualSucesso: totalValidos > 0 ? parseFloat(((sucessos / totalValidos) * 100).toFixed(1)) : 0,
        percentualErros: totalValidos > 0 ? parseFloat(((erros / totalValidos) * 100).toFixed(1)) : 0
      }
    };
  }

  getStatus() {
    return {
      isRunning: this.isRunning,
      progress: this.currentProgress,
      totalOrgaos: this.totalOrgaos,
      processedCount: this.results.length
    };
  }
}

// Fun√ß√£o principal para execu√ß√£o standalone
async function main() {
  try {
    // Carregar configura√ß√£o
    const config = loadConfig();
        
    if (!config.cpf || !config.orgaos || config.orgaos.length === 0) {
      throw new Error('Configura√ß√£o inv√°lida: CPF e lista de √≥rg√£os s√£o obrigat√≥rios');
    }
        
    // Criar inst√¢ncia da automa√ß√£o
    const automation = new ServidorAutomationV2();
        
    // Executar automa√ß√£o
    await automation.startAutomation(config);
        
    console.log('Automa√ß√£o conclu√≠da com sucesso!');
        
  } catch (error) {
    console.error('Erro na automa√ß√£o:', error);
    process.exit(1);
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  main().catch(console.error);
}

module.exports = ServidorAutomationV2;