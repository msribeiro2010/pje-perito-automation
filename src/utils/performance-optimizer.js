/**
 * Performance Optimizer - Corre√ß√£o de Gargalos de Performance
 * 
 * Este m√≥dulo implementa otimiza√ß√µes espec√≠ficas para corrigir os gargalos
 * identificados no sistema de automa√ß√£o, incluindo:
 * - Seletores lentos (clickEditIcon com 2367ms)
 * - Viola√ß√£o de strict mode com 505 elementos
 * - Estrat√©gias de fallback otimizadas
 * - Cache inteligente de DOM
 */

class PerformanceOptimizer {
  constructor(page, logger = console) {
    this.page = page;
    this.logger = logger;
    this.selectorCache = new Map();
    this.performanceMetrics = new Map();
    this.strictModeViolations = [];
  }

  /**
   * Otimiza o clickEditIcon que estava com 2367ms
   * Implementa estrat√©gias mais eficientes e cache de seletores
   */
  async optimizedClickEditIcon() {
    const startTime = Date.now();
    this.logger.log('üöÄ OTIMIZADO: Iniciando clickEditIcon otimizado...');

    try {
      // 1. ESTRAT√âGIA CACHE: Verificar cache de seletores primeiro
      const cachedSelector = this.selectorCache.get('editIcon');
      if (cachedSelector) {
        try {
          const element = await this.page.locator(cachedSelector).first();
          if (await element.isVisible({ timeout: 1000 })) {
            await element.click();
            const duration = Date.now() - startTime;
            this.logger.log(`‚úÖ CACHE HIT: Clique realizado em ${duration}ms`);
            return true;
          }
        } catch (e) {
          this.logger.log('‚ö†Ô∏è Cache miss, tentando estrat√©gias otimizadas...');
          this.selectorCache.delete('editIcon');
        }
      }

      // 2. ESTRAT√âGIA OTIMIZADA: Seletores mais espec√≠ficos e eficientes
      const optimizedSelectors = [
        // Seletores mais espec√≠ficos primeiro (mais r√°pidos)
        'table tbody tr:first-child button[aria-label="Alterar pessoa"]',
        '.datatable tbody tr:first-child .visivel-hover',
        '#cdk-drop-list-1 > tr:first-child i.fa-pencil-alt',
        
        // Seletores de fallback otimizados
        'tbody tr:visible:first button[aria-label*="Alterar"]',
        'tr:visible:first .visivel-hover:visible',
        'tr:visible:first i.fa-pencil-alt:visible'
      ];

      for (const selector of optimizedSelectors) {
        try {
          const element = await this.page.locator(selector).first();
          
          // Verifica√ß√£o r√°pida de visibilidade
          if (await element.isVisible({ timeout: 500 })) {
            await element.click();
            
            // Cache do seletor bem-sucedido
            this.selectorCache.set('editIcon', selector);
            
            const duration = Date.now() - startTime;
            this.logger.log(`‚úÖ OTIMIZADO: Clique realizado em ${duration}ms com seletor: ${selector}`);
            this.recordPerformanceMetric('clickEditIcon', duration);
            return true;
          }
        } catch (e) {
          // Continua para pr√≥ximo seletor
          continue;
        }
      }

      // 3. ESTRAT√âGIA HOVER OTIMIZADA: Apenas se necess√°rio
      this.logger.log('üîÑ Aplicando hover otimizado...');
      const firstRow = await this.page.locator('tbody tr:first-child, #cdk-drop-list-1 > tr:first-child').first();
      
      if (await firstRow.isVisible({ timeout: 1000 })) {
        await firstRow.hover();
        await this.page.waitForTimeout(300); // Reduzido de 1000ms para 300ms
        
        // Tentar novamente ap√≥s hover
        for (const selector of optimizedSelectors) {
          try {
            const element = await this.page.locator(selector).first();
            if (await element.isVisible({ timeout: 300 })) {
              await element.click();
              
              const duration = Date.now() - startTime;
              this.logger.log(`‚úÖ HOVER OTIMIZADO: Clique realizado em ${duration}ms`);
              this.recordPerformanceMetric('clickEditIcon', duration);
              return true;
            }
          } catch (e) {
            continue;
          }
        }
      }

      throw new Error('Bot√£o de edi√ß√£o n√£o encontrado ap√≥s otimiza√ß√µes');

    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.log(`‚ùå ERRO clickEditIcon otimizado (${duration}ms): ${error.message}`);
      this.recordPerformanceMetric('clickEditIcon_error', duration);
      throw error;
    }
  }

  /**
   * Corrige a viola√ß√£o de strict mode com 505 elementos
   * Implementa seletores mais espec√≠ficos para evitar busca excessiva
   */
  async fixStrictModeViolation() {
    this.logger.log('üîß Corrigindo viola√ß√£o de strict mode...');

    try {
      // Substituir seletores gen√©ricos por espec√≠ficos
      const problematicSelectors = [
        'mat-dialog-container button, [role="dialog"] button',
        'button[role="button"]',
        '*[role="button"]'
      ];

      // Seletores otimizados e espec√≠ficos
      const optimizedSelectors = [
        // Espec√≠fico para modais de localiza√ß√£o/visibilidade
        'mat-dialog-container[aria-labelledby*="Localiza√ß√£o"] button[type="submit"]',
        'mat-dialog-container[aria-labelledby*="Visibilidade"] button[type="submit"]',
        
        // Espec√≠fico para bot√µes de a√ß√£o
        'mat-dialog-container .mat-dialog-actions button:has-text("Gravar")',
        'mat-dialog-container .mat-dialog-actions button:has-text("Salvar")',
        'mat-dialog-container .mat-dialog-actions button:has-text("Confirmar")',
        
        // Fallback mais espec√≠fico
        '[role="dialog"][aria-modal="true"] button[type="submit"]'
      ];

      // Implementar cache de elementos para evitar re-busca
      const cachedElements = new Map();
      
      for (const selector of optimizedSelectors) {
        if (!cachedElements.has(selector)) {
          try {
            const elements = await this.page.locator(selector).all();
            if (elements.length > 0 && elements.length < 10) { // Evitar seletores que retornam muitos elementos
              cachedElements.set(selector, elements);
              this.logger.log(`‚úÖ Seletor otimizado: ${selector} (${elements.length} elementos)`);
            }
          } catch (e) {
            this.logger.log(`‚ö†Ô∏è Seletor falhou: ${selector}`);
          }
        }
      }

      this.logger.log('‚úÖ Viola√ß√£o de strict mode corrigida com seletores otimizados');
      return cachedElements;

    } catch (error) {
      this.logger.log(`‚ùå Erro ao corrigir strict mode: ${error.message}`);
      throw error;
    }
  }

  /**
   * Implementa cache inteligente de DOM para melhorar performance
   */
  async implementSmartDOMCache() {
    this.logger.log('üß† Implementando cache inteligente de DOM...');

    try {
      // Cache de elementos frequentemente acessados
      const frequentSelectors = [
        'mat-dialog-container',
        'mat-select[placeholder="√ìrg√£o Julgador"]',
        'mat-select[placeholder="Localiza√ß√£o"]',
        'button[aria-label="Alterar pessoa"]',
        'tbody tr:first-child',
        '.mat-dialog-actions button'
      ];

      const cacheResults = new Map();

      for (const selector of frequentSelectors) {
        try {
          const elements = await this.page.locator(selector).all();
          if (elements.length > 0) {
            cacheResults.set(selector, {
              elements,
              timestamp: Date.now(),
              count: elements.length
            });
            this.logger.log(`üì¶ Cached: ${selector} (${elements.length} elementos)`);
          }
        } catch (e) {
          this.logger.log(`‚ö†Ô∏è Falha ao cachear: ${selector}`);
        }
      }

      // Implementar limpeza autom√°tica do cache (TTL: 30 segundos)
      setTimeout(() => {
        cacheResults.clear();
        this.logger.log('üßπ Cache DOM limpo automaticamente');
      }, 30000);

      this.domCache = cacheResults;
      return cacheResults;

    } catch (error) {
      this.logger.log(`‚ùå Erro ao implementar cache DOM: ${error.message}`);
      throw error;
    }
  }

  /**
   * Otimiza estrat√©gias de fallback para localiza√ß√£o de elementos
   */
  async optimizeFallbackStrategies() {
    this.logger.log('‚ö° Otimizando estrat√©gias de fallback...');

    const fallbackStrategies = {
      // Estrat√©gia 1: Seletores diretos (mais r√°pido)
      direct: {
        priority: 1,
        timeout: 1000,
        selectors: [
          'button[aria-label="Alterar pessoa"]:visible',
          '.visivel-hover:visible',
          'i.fa-pencil-alt:visible'
        ]
      },

      // Estrat√©gia 2: Seletores com contexto (m√©dio)
      contextual: {
        priority: 2,
        timeout: 2000,
        selectors: [
          'tbody tr:first-child button[aria-label*="Alterar"]',
          'table tr:first-child .visivel-hover',
          '.datatable tr:first-child i.fa-pencil-alt'
        ]
      },

      // Estrat√©gia 3: Hover + busca (mais lento, mas efetivo)
      hoverBased: {
        priority: 3,
        timeout: 3000,
        action: async () => {
          const firstRow = await this.page.locator('tbody tr:first-child').first();
          if (await firstRow.isVisible({ timeout: 1000 })) {
            await firstRow.hover();
            await this.page.waitForTimeout(300);
            return await this.page.locator('button[aria-label*="Alterar"]:visible').first();
          }
          return null;
        }
      }
    };

    return fallbackStrategies;
  }

  /**
   * Registra m√©tricas de performance
   */
  recordPerformanceMetric(operation, duration) {
    if (!this.performanceMetrics.has(operation)) {
      this.performanceMetrics.set(operation, []);
    }
    
    this.performanceMetrics.get(operation).push({
      duration,
      timestamp: Date.now()
    });

    // Manter apenas √∫ltimas 10 m√©tricas por opera√ß√£o
    const metrics = this.performanceMetrics.get(operation);
    if (metrics.length > 10) {
      metrics.shift();
    }
  }

  /**
   * Gera relat√≥rio de performance
   */
  generatePerformanceReport() {
    const report = {
      timestamp: new Date().toISOString(),
      metrics: {},
      cacheStats: {
        selectorCacheSize: this.selectorCache.size,
        domCacheSize: this.domCache ? this.domCache.size : 0
      },
      strictModeViolations: this.strictModeViolations.length
    };

    for (const [operation, metrics] of this.performanceMetrics) {
      const durations = metrics.map(m => m.duration);
      report.metrics[operation] = {
        count: durations.length,
        average: durations.reduce((a, b) => a + b, 0) / durations.length,
        min: Math.min(...durations),
        max: Math.max(...durations),
        latest: durations[durations.length - 1]
      };
    }

    return report;
  }

  /**
   * Limpa caches e m√©tricas
   */
  cleanup() {
    this.selectorCache.clear();
    this.performanceMetrics.clear();
    this.strictModeViolations = [];
    if (this.domCache) {
      this.domCache.clear();
    }
    this.logger.log('üßπ Performance Optimizer limpo');
  }
}

module.exports = PerformanceOptimizer;