const { Logger } = require('./Logger');

/**
 * Sistema inteligente para detectar quando todos os OJs de um servidor j√° est√£o cadastrados
 * e automaticamente pular para o pr√≥ximo servidor
 */
class ServidorSkipDetector {
  constructor() {
    this.logger = new Logger('ServidorSkipDetector');
    this.servidoresAnalisados = new Map(); // Map<servidorId, { totalOJs, ojsVinculados, ultimaVerificacao }>
    this.limiteTolerancia = 0.95; // 95% dos OJs vinculados = servidor completo
    this.limiteMinimo = 3; // M√≠nimo de OJs para considerar an√°lise v√°lida
  }

  /**
   * Analisa se um servidor deve ser pulado baseado no hist√≥rico de OJs j√° vinculados
   * @param {string} servidorId - ID √∫nico do servidor
   * @param {Array} ojsNormalizados - Lista de OJs normalizados que seriam processados
   * @param {Object} smartOJCache - Inst√¢ncia do cache inteligente
   * @returns {Object} Resultado da an√°lise
   */
  analisarServidor(servidorId, ojsNormalizados, smartOJCache) {
    console.log(`\nüîç [SKIP-DETECTOR] Analisando servidor ${servidorId}...`);
    console.log(`üìä [SKIP-DETECTOR] Total de OJs para verificar: ${ojsNormalizados.length}`);
    
    // Valida√ß√£o de entrada
    if (!servidorId || typeof servidorId !== 'string') {
      console.log(`‚ö†Ô∏è [SKIP-DETECTOR] ID do servidor inv√°lido: ${servidorId}`);
      return {
        deveSerPulado: false,
        motivo: 'ID do servidor inv√°lido - servidor ser√° processado',
        estatisticas: {
          totalOJs: ojsNormalizados ? ojsNormalizados.length : 0,
          ojsVinculados: 0,
          porcentagemVinculada: 0
        }
      };
    }
    
    if (!ojsNormalizados || !Array.isArray(ojsNormalizados) || ojsNormalizados.length === 0) {
      console.log(`‚ö†Ô∏è [SKIP-DETECTOR] Lista de OJs inv√°lida ou vazia`);
      return {
        deveSerPulado: false,
        motivo: 'Nenhum OJ v√°lido para analisar - servidor ser√° processado',
        estatisticas: {
          totalOJs: 0,
          ojsVinculados: 0,
          porcentagemVinculada: 0
        }
      };
    }
    
    // Verificar se o smartOJCache √© v√°lido
    if (!smartOJCache || typeof smartOJCache !== 'object') {
      console.log(`‚ö†Ô∏è [SKIP-DETECTOR] SmartOJCache inv√°lido - servidor ser√° processado`);
      return {
        deveSerPulado: false,
        motivo: 'Cache n√£o dispon√≠vel - servidor ser√° processado',
        estatisticas: {
          totalOJs: ojsNormalizados.length,
          ojsVinculados: 0,
          porcentagemVinculada: 0
        }
      };
    }
    
    // Verificar se o cache est√° v√°lido
    if (!smartOJCache.cacheValido) {
      console.log(`‚ö†Ô∏è [SKIP-DETECTOR] Cache n√£o est√° v√°lido - servidor ser√° processado para atualizar dados`);
      return {
        deveSerPulado: false,
        motivo: 'Cache inv√°lido - necess√°rio processar para atualizar',
        estatisticas: {
          totalOJs: ojsNormalizados.length,
          ojsVinculados: 0,
          porcentagemVinculada: 0
        }
      };
    }
    
    // Verificar quantos OJs j√° est√£o vinculados
    let ojsVinculados = 0;
    let ojsComErro = 0;
    const detalhesOJs = [];
    
    ojsNormalizados.forEach((oj, index) => {
      try {
        // Validar OJ antes de verificar
        if (!oj || typeof oj !== 'string' || oj.trim().length === 0) {
          console.log(`‚ö†Ô∏è [SKIP-DETECTOR] OJ ${index + 1}/${ojsNormalizados.length} inv√°lido: ${oj}`);
          ojsComErro++;
          detalhesOJs.push({
            oj: oj,
            vinculado: false,
            erro: 'OJ inv√°lido'
          });
          return;
        }
        
        const jaVinculado = smartOJCache.isOJVinculado(oj);
        
        detalhesOJs.push({
          oj: oj,
          vinculado: jaVinculado,
          erro: null
        });
        
        if (jaVinculado) {
          ojsVinculados++;
          console.log(`‚úÖ [SKIP-DETECTOR] OJ ${index + 1}/${ojsNormalizados.length} j√° vinculado: ${oj.substring(0, 50)}...`);
        } else {
          console.log(`‚ùå [SKIP-DETECTOR] OJ ${index + 1}/${ojsNormalizados.length} N√ÉO vinculado: ${oj.substring(0, 50)}...`);
        }
      } catch (error) {
        console.error(`‚ùå [SKIP-DETECTOR] Erro verificando OJ ${index + 1}: ${error.message}`);
        ojsComErro++;
        detalhesOJs.push({
          oj: oj,
          vinculado: false,
          erro: error.message
        });
      }
    });
    
    const ojsValidos = ojsNormalizados.length - ojsComErro;
    const porcentagemVinculada = ojsValidos > 0 ? (ojsVinculados / ojsValidos) * 100 : 0;
    const ojsParaVincular = ojsValidos - ojsVinculados;
    
    console.log(`\nüìà [SKIP-DETECTOR] Estat√≠sticas do servidor ${servidorId}:`);
    console.log(`   - Total de OJs: ${ojsNormalizados.length}`);
    console.log(`   - OJs v√°lidos: ${ojsValidos}`);
    console.log(`   - OJs com erro: ${ojsComErro}`);
    console.log(`   - OJs j√° vinculados: ${ojsVinculados}`);
    console.log(`   - OJs para vincular: ${ojsParaVincular}`);
    console.log(`   - Porcentagem vinculada: ${porcentagemVinculada.toFixed(1)}%`);
    
    if (ojsComErro > 0) {
      console.log(`   ‚ö†Ô∏è Aten√ß√£o: ${ojsComErro} OJs com problemas foram ignorados na an√°lise`);
    }
    
    // Determinar a√ß√£o baseada na an√°lise
    const decisao = this.determinarAcao({
      servidorId,
      totalOJs: ojsNormalizados.length,
      ojsValidos,
      ojsComErro,
      ojsVinculados,
      ojsParaVincular,
      porcentagemVinculada,
      detalhesOJs
    });
    
    console.log(`\nüéØ [SKIP-DETECTOR] Decis√£o para servidor ${servidorId}: ${decisao.deveSerPulado ? 'PULAR' : 'PROCESSAR'}`);
    console.log(`   - Motivo: ${decisao.motivo}`);
    
    return decisao;
  }

  /**
   * Determina a a√ß√£o a ser tomada baseada nas estat√≠sticas
   * @param {Object} dados - Dados da an√°lise do servidor
   * @returns {Object} Decis√£o sobre a a√ß√£o
   */
  determinarAcao(dados) {
    const { 
      servidorId, 
      totalOJs, 
      ojsValidos = totalOJs, 
      ojsComErro = 0, 
      ojsVinculados, 
      ojsParaVincular = ojsValidos - ojsVinculados, 
      porcentagemVinculada, 
      detalhesOJs 
    } = dados;
    
    const historico = this.servidoresAnalisados.get(servidorId);
    
    // Cen√°rio 0: Muitos OJs com erro - processar para investigar
    if (ojsComErro > 0 && (ojsComErro / totalOJs) > 0.2) {
      return {
        deveSerPulado: false,
        motivo: `${ojsComErro} OJs com erro (${((ojsComErro / totalOJs) * 100).toFixed(1)}%) - servidor ser√° processado para investigar`,
        estatisticas: {
          totalOJs,
          ojsValidos,
          ojsComErro,
          ojsVinculados,
          ojsParaVincular,
          porcentagemVinculada
        }
      };
    }
    
    // Cen√°rio 1: Poucos OJs v√°lidos para processar
    if (ojsValidos < this.limiteMinimo) {
      return {
        deveSerPulado: false,
        motivo: `Servidor tem apenas ${ojsValidos} OJs v√°lidos (abaixo do limite m√≠nimo de ${this.limiteMinimo}) - ser√° processado`,
        estatisticas: {
          totalOJs,
          ojsValidos,
          ojsComErro,
          ojsVinculados,
          ojsParaVincular,
          porcentagemVinculada
        }
      };
    }
    
    // Cen√°rio 2: Todos os OJs j√° est√£o vinculados
    if (ojsVinculados === totalOJs) {
      return {
        deveSerPulado: true,
        motivo: `Todos os ${totalOJs} OJs j√° est√£o vinculados (100%) - servidor ser√° pulado`,
        estatisticas: {
          totalOJs,
          ojsValidos,
          ojsComErro,
          ojsVinculados,
          ojsParaVincular,
          porcentagemVinculada
        }
      };
    }

    // Cen√°rio 3: Percentual muito alto de OJs vinculados
    if (porcentagemVinculada >= (this.limiteTolerancia * 100) && totalOJs >= this.limiteMinimo) {
      return {
        deveSerPulado: true,
        motivo: `${porcentagemVinculada.toFixed(1)}% dos OJs j√° vinculados (limite: ${(this.limiteTolerancia * 100)}%) - servidor ser√° pulado`,
        estatisticas: {
          totalOJs,
          ojsValidos,
          ojsComErro,
          ojsVinculados,
          ojsParaVincular,
          porcentagemVinculada
        }
      };
    }

    // Cen√°rio 4: Hist√≥rico indica servidor est√°vel
    if (historico && this.analisarTendenciaHistorica(historico, {
      totalOJs,
      ojsJaVinculados: ojsVinculados,
      percentualVinculado: porcentagemVinculada / 100
    })) {
      return {
        deveSerPulado: true,
        motivo: 'Hist√≥rico indica servidor est√°vel sem novos OJs - servidor ser√° pulado',
        estatisticas: {
          totalOJs,
          ojsValidos,
          ojsComErro,
          ojsVinculados,
          ojsParaVincular,
          porcentagemVinculada
        }
      };
    }

    // Cen√°rio padr√£o: processar
    return {
      deveSerPulado: false,
      motivo: `${ojsParaVincular} OJs novos encontrados (${porcentagemVinculada.toFixed(1)}% vinculados) - servidor ser√° processado`,
      estatisticas: {
        totalOJs,
        ojsValidos,
        ojsComErro,
        ojsVinculados,
        ojsParaVincular,
        porcentagemVinculada
      }
    };
  }

  /**
   * Analisa tend√™ncia hist√≥rica do servidor
   * @param {Object} historico - Hist√≥rico do servidor
   * @param {Object} statsAtuais - Estat√≠sticas atuais
   * @returns {boolean} True se indica estabilidade
   */
  analisarTendenciaHistorica(historico, statsAtuais) {
    // Se o hist√≥rico mostra que nas √∫ltimas 3 verifica√ß√µes n√£o houve novos OJs
    const tempoDecorrido = Date.now() - historico.ultimaVerificacao;
    const umDiaEmMs = 24 * 60 * 60 * 1000;
    
    // Se foi verificado recentemente (menos de 1 dia) e n√£o havia OJs novos
    if (tempoDecorrido < umDiaEmMs && historico.ojsParaVincular === 0) {
      return true;
    }

    // Se o n√∫mero de OJs vinculados n√£o mudou significativamente
    const diferencaPercentual = Math.abs(statsAtuais.percentualVinculado - historico.percentualVinculado);
    if (diferencaPercentual < 0.05 && statsAtuais.percentualVinculado > 0.8) { // Menos de 5% de diferen√ßa e mais de 80% vinculado
      return true;
    }

    return false;
  }

  /**
   * Atualiza o hist√≥rico de um servidor
   * @param {string} servidorId - ID do servidor
   * @param {Object} stats - Estat√≠sticas atuais
   */
  atualizarHistoricoServidor(servidorId, stats) {
    this.servidoresAnalisados.set(servidorId, {
      totalOJs: stats.totalOJs,
      ojsVinculados: stats.ojsJaVinculados,
      ojsParaVincular: stats.ojsParaVincular,
      percentualVinculado: stats.percentualVinculado,
      ultimaVerificacao: Date.now()
    });
  }

  /**
   * Gera relat√≥rio de efici√™ncia dos servidores
   * @returns {Object} Relat√≥rio completo
   */
  gerarRelatorioEficiencia() {
    const relatorio = {
      totalServidores: this.servidoresAnalisados.size,
      servidoresCompletos: 0,
      servidoresQuaseCompletos: 0,
      servidoresAtivos: 0,
      economiaEstimada: 0,
      detalhes: []
    };

    this.servidoresAnalisados.forEach((dados, servidorId) => {
      const detalhe = {
        servidorId,
        status: '',
        percentualCompleto: (dados.percentualVinculado * 100).toFixed(1),
        ojsVinculados: dados.ojsVinculados,
        ojsParaVincular: dados.ojsParaVincular,
        ultimaVerificacao: new Date(dados.ultimaVerificacao).toLocaleString()
      };

      if (dados.percentualVinculado >= 1.0) {
        detalhe.status = '‚úÖ Completo';
        relatorio.servidoresCompletos++;
        relatorio.economiaEstimada += dados.totalOJs * 5; // 5s por OJ
      } else if (dados.percentualVinculado >= this.limiteTolerancia) {
        detalhe.status = 'üü° Quase Completo';
        relatorio.servidoresQuaseCompletos++;
        relatorio.economiaEstimada += dados.ojsVinculados * 5;
      } else {
        detalhe.status = 'üîÑ Ativo';
        relatorio.servidoresAtivos++;
      }

      relatorio.detalhes.push(detalhe);
    });

    return relatorio;
  }

  /**
   * Limpa o hist√≥rico de servidores (√∫til para reset)
   */
  limparHistorico() {
    this.servidoresAnalisados.clear();
    this.logger.info('üßπ Hist√≥rico de servidores limpo');
  }

  /**
   * Configura limites de toler√¢ncia
   * @param {number} limiteTolerancia - Percentual de 0 a 1
   * @param {number} limiteMinimo - N√∫mero m√≠nimo de OJs
   */
  configurarLimites(limiteTolerancia = 0.95, limiteMinimo = 3) {
    this.limiteTolerancia = Math.max(0.5, Math.min(1.0, limiteTolerancia));
    this.limiteMinimo = Math.max(1, limiteMinimo);
    this.logger.info(`‚öôÔ∏è Limites configurados: ${(this.limiteTolerancia * 100)}% toler√¢ncia, ${this.limiteMinimo} OJs m√≠nimo`);
  }
}

module.exports = { ServidorSkipDetector };