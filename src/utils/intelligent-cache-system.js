/**
 * üß† INTELLIGENT CACHE SYSTEM
 * Sistema de cache inteligente para evitar reprocessamento desnecess√°rio
 * Implementa cache multi-camadas com TTL adaptativo e invalida√ß√£o inteligente
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class IntelligentCacheSystem {
  constructor(options = {}) {
    this.config = {
      // Cache em mem√≥ria
      memory: {
        enabled: true,
        maxSize: options.memoryMaxSize || 1000,
        defaultTTL: options.memoryTTL || 300000, // 5 minutos
        cleanupInterval: options.cleanupInterval || 60000 // 1 minuto
      },
            
      // Cache em disco
      disk: {
        enabled: options.diskCache !== false,
        directory: options.cacheDir || path.join(process.cwd(), '.cache'),
        maxSize: options.diskMaxSize || 100, // 100 arquivos
        defaultTTL: options.diskTTL || 3600000 // 1 hora
      },
            
      // Cache inteligente
      intelligent: {
        enabled: true,
        adaptiveTTL: true,
        hitRateThreshold: 0.8, // 80% de hit rate para aumentar TTL
        missRateThreshold: 0.3, // 30% de miss rate para diminuir TTL
        ttlAdjustmentFactor: 1.5 // Fator de ajuste do TTL
      }
    };
        
    // Cache em mem√≥ria
    this.memoryCache = new Map();
        
    // Estat√≠sticas
    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      evictions: 0,
      diskHits: 0,
      diskMisses: 0,
      totalTimeSaved: 0,
      operationsSaved: 0
    };
        
    // Metadados para cache inteligente
    this.metadata = new Map();
        
    // Inicializar limpeza autom√°tica
    this.startCleanupTimer();
        
    // Criar diret√≥rio de cache se necess√°rio
    this.initializeDiskCache();
  }

  /**
     * üöÄ OBTER DADOS DO CACHE (M√âTODO PRINCIPAL)
     */
  async get(key, options = {}) {
    const startTime = Date.now();
    const cacheKey = this.generateCacheKey(key);
        
    try {
      // 1. Tentar cache em mem√≥ria primeiro
      const memoryResult = this.getFromMemory(cacheKey);
      if (memoryResult !== null) {
        this.recordHit('memory', Date.now() - startTime);
        console.log(`üéØ [CACHE] Hit em mem√≥ria: ${key}`);
        return memoryResult;
      }
            
      // 2. Tentar cache em disco
      if (this.config.disk.enabled) {
        const diskResult = await this.getFromDisk(cacheKey);
        if (diskResult !== null) {
          // Promover para mem√≥ria
          this.setInMemory(cacheKey, diskResult, options.ttl);
          this.recordHit('disk', Date.now() - startTime);
          console.log(`üíæ [CACHE] Hit em disco (promovido): ${key}`);
          return diskResult;
        }
      }
            
      // 3. Cache miss
      this.recordMiss(Date.now() - startTime);
      console.log(`‚ùå [CACHE] Miss: ${key}`);
      return null;
            
    } catch (error) {
      console.error(`‚ùå [CACHE] Erro ao obter ${key}:`, error.message);
      this.recordMiss(Date.now() - startTime);
      return null;
    }
  }

  /**
     * üíæ ARMAZENAR DADOS NO CACHE
     */
  async set(key, value, options = {}) {
    const startTime = Date.now();
    const cacheKey = this.generateCacheKey(key);
        
    try {
      // Calcular TTL inteligente
      const ttl = this.calculateIntelligentTTL(key, options.ttl);
            
      // Armazenar em mem√≥ria
      this.setInMemory(cacheKey, value, ttl);
            
      // Armazenar em disco se habilitado
      if (this.config.disk.enabled && options.persistToDisk !== false) {
        await this.setOnDisk(cacheKey, value, ttl);
      }
            
      // Atualizar metadados
      this.updateMetadata(cacheKey, {
        key,
        size: this.calculateSize(value),
        createdAt: Date.now(),
        ttl,
        accessCount: 0,
        lastAccess: Date.now()
      });
            
      this.stats.sets++;
      console.log(`‚úÖ [CACHE] Armazenado: ${key} (TTL: ${ttl}ms)`);
            
    } catch (error) {
      console.error(`‚ùå [CACHE] Erro ao armazenar ${key}:`, error.message);
    }
  }

  /**
     * üß† CACHE INTELIGENTE COM FUN√á√ÉO
     */
  async getOrCompute(key, computeFunction, options = {}) {
    const startTime = Date.now();
        
    // Tentar obter do cache
    const cached = await this.get(key, options);
    if (cached !== null) {
      return cached;
    }
        
    console.log(`üîÑ [CACHE] Computando: ${key}`);
        
    try {
      // Computar valor
      const computeStartTime = Date.now();
      const value = await computeFunction();
      const computeTime = Date.now() - computeStartTime;
            
      // Armazenar no cache
      await this.set(key, value, {
        ...options,
        computeTime
      });
            
      // Registrar economia de tempo para pr√≥ximas chamadas
      this.stats.totalTimeSaved += computeTime;
      this.stats.operationsSaved++;
            
      console.log(`‚úÖ [CACHE] Computado e armazenado: ${key} (${computeTime}ms)`);
      return value;
            
    } catch (error) {
      console.error(`‚ùå [CACHE] Erro ao computar ${key}:`, error.message);
      throw error;
    }
  }

  /**
     * üéØ CACHE ESPEC√çFICO PARA OJs
     */
  async cacheOJAnalysis(servidor, analysisFunction) {
    const key = `oj_analysis_${servidor.cpf}_${servidor.nome}`;
        
    return await this.getOrCompute(key, analysisFunction, {
      ttl: 600000, // 10 minutos para an√°lise de OJ
      category: 'oj_analysis',
      persistToDisk: true
    });
  }

  /**
     * üîç CACHE PARA RESULTADOS DE BUSCA
     */
  async cacheSearchResults(searchParams, searchFunction) {
    const key = `search_${this.hashObject(searchParams)}`;
        
    return await this.getOrCompute(key, searchFunction, {
      ttl: 300000, // 5 minutos para resultados de busca
      category: 'search_results',
      persistToDisk: false // N√£o persistir buscas em disco
    });
  }

  /**
     * üìä CACHE PARA ESTAT√çSTICAS
     */
  async cacheStats(statsKey, statsFunction) {
    const key = `stats_${statsKey}`;
        
    return await this.getOrCompute(key, statsFunction, {
      ttl: 60000, // 1 minuto para estat√≠sticas
      category: 'statistics',
      persistToDisk: false
    });
  }

  /**
     * üßÆ CALCULAR TTL INTELIGENTE
     */
  calculateIntelligentTTL(key, requestedTTL) {
    if (!this.config.intelligent.adaptiveTTL) {
      return requestedTTL || this.config.memory.defaultTTL;
    }
        
    const hitRate = this.getHitRate();
    const baseTTL = requestedTTL || this.config.memory.defaultTTL;
        
    // Ajustar TTL baseado na taxa de hit
    if (hitRate > this.config.intelligent.hitRateThreshold) {
      // Alta taxa de hit - aumentar TTL
      return Math.round(baseTTL * this.config.intelligent.ttlAdjustmentFactor);
    } else if (hitRate < this.config.intelligent.missRateThreshold) {
      // Alta taxa de miss - diminuir TTL
      return Math.round(baseTTL / this.config.intelligent.ttlAdjustmentFactor);
    }
        
    return baseTTL;
  }

  /**
     * üí≠ CACHE EM MEM√ìRIA - GET
     */
  getFromMemory(cacheKey) {
    const item = this.memoryCache.get(cacheKey);
        
    if (!item) {
      return null;
    }
        
    // Verificar expira√ß√£o
    if (Date.now() > item.expiresAt) {
      this.memoryCache.delete(cacheKey);
      this.metadata.delete(cacheKey);
      return null;
    }
        
    // Atualizar metadados de acesso
    const metadata = this.metadata.get(cacheKey);
    if (metadata) {
      metadata.accessCount++;
      metadata.lastAccess = Date.now();
    }
        
    return item.value;
  }

  /**
     * üí≠ CACHE EM MEM√ìRIA - SET
     */
  setInMemory(cacheKey, value, ttl) {
    const effectiveTTL = ttl || this.config.memory.defaultTTL;
    const expiresAt = Date.now() + effectiveTTL;
        
    // Verificar limite de tamanho
    if (this.memoryCache.size >= this.config.memory.maxSize) {
      this.evictLeastRecentlyUsed();
    }
        
    this.memoryCache.set(cacheKey, {
      value,
      createdAt: Date.now(),
      expiresAt
    });
  }

  /**
     * üíæ CACHE EM DISCO - GET
     */
  async getFromDisk(cacheKey) {
    try {
      const filePath = this.getDiskCachePath(cacheKey);
      const data = await fs.readFile(filePath, 'utf8');
      const item = JSON.parse(data);
            
      // Verificar expira√ß√£o
      if (Date.now() > item.expiresAt) {
        await fs.unlink(filePath).catch(() => {}); // Ignorar erros de exclus√£o
        return null;
      }
            
      this.stats.diskHits++;
      return item.value;
            
    } catch (error) {
      this.stats.diskMisses++;
      return null;
    }
  }

  /**
     * üíæ CACHE EM DISCO - SET
     */
  async setOnDisk(cacheKey, value, ttl) {
    try {
      const effectiveTTL = ttl || this.config.disk.defaultTTL;
      const expiresAt = Date.now() + effectiveTTL;
            
      const item = {
        value,
        createdAt: Date.now(),
        expiresAt
      };
            
      const filePath = this.getDiskCachePath(cacheKey);
      await fs.writeFile(filePath, JSON.stringify(item), 'utf8');
            
    } catch (error) {
      console.error('‚ùå [CACHE] Erro ao salvar em disco:', error.message);
    }
  }

  /**
     * üóëÔ∏è EVIC√á√ÉO LRU (Least Recently Used)
     */
  evictLeastRecentlyUsed() {
    let oldestKey = null;
    let oldestTime = Date.now();
        
    for (const [key, metadata] of this.metadata.entries()) {
      if (metadata.lastAccess < oldestTime) {
        oldestTime = metadata.lastAccess;
        oldestKey = key;
      }
    }
        
    if (oldestKey) {
      this.memoryCache.delete(oldestKey);
      this.metadata.delete(oldestKey);
      this.stats.evictions++;
      console.log(`üóëÔ∏è [CACHE] Evictado: ${oldestKey}`);
    }
  }

  /**
     * üßπ LIMPEZA AUTOM√ÅTICA
     */
  startCleanupTimer() {
    setInterval(() => {
      this.cleanup();
    }, this.config.memory.cleanupInterval);
  }

  /**
     * üßπ EXECUTAR LIMPEZA
     */
  cleanup() {
    const now = Date.now();
    let cleaned = 0;
        
    // Limpar cache em mem√≥ria
    for (const [key, item] of this.memoryCache.entries()) {
      if (now > item.expiresAt) {
        this.memoryCache.delete(key);
        this.metadata.delete(key);
        cleaned++;
      }
    }
        
    if (cleaned > 0) {
      console.log(`üßπ [CACHE] Limpeza: ${cleaned} itens removidos`);
    }
  }

  /**
     * üîë GERAR CHAVE DE CACHE
     */
  generateCacheKey(key) {
    if (typeof key === 'string') {
      return key;
    }
    return this.hashObject(key);
  }

  /**
     * #Ô∏è‚É£ HASH DE OBJETO
     */
  hashObject(obj) {
    const str = JSON.stringify(obj, Object.keys(obj).sort());
    return crypto.createHash('md5').update(str).digest('hex');
  }

  /**
     * üìè CALCULAR TAMANHO
     */
  calculateSize(value) {
    return JSON.stringify(value).length;
  }

  /**
     * üìä REGISTRAR HIT
     */
  recordHit(type, responseTime) {
    this.stats.hits++;
    if (type === 'disk') {
      this.stats.diskHits++;
    }
        
    // Estimar tempo economizado (baseado em opera√ß√µes t√≠picas)
    const estimatedSavedTime = 2000; // 2 segundos por opera√ß√£o t√≠pica
    this.stats.totalTimeSaved += estimatedSavedTime;
    this.stats.operationsSaved++;
  }

  /**
     * üìä REGISTRAR MISS
     */
  recordMiss(responseTime) {
    this.stats.misses++;
  }

  /**
     * üìà CALCULAR TAXA DE HIT
     */
  getHitRate() {
    const total = this.stats.hits + this.stats.misses;
    return total > 0 ? this.stats.hits / total : 0;
  }

  /**
     * üìä OBTER ESTAT√çSTICAS
     */
  getStats() {
    const hitRate = this.getHitRate();
    const memoryUsage = this.memoryCache.size;
    const avgTimeSaved = this.stats.operationsSaved > 0 ? 
      Math.round(this.stats.totalTimeSaved / this.stats.operationsSaved) : 0;
        
    return {
      ...this.stats,
      hitRate: Math.round(hitRate * 100),
      memoryUsage,
      maxMemorySize: this.config.memory.maxSize,
      avgTimeSavedPerOperation: avgTimeSaved,
      totalTimeSavedSeconds: Math.round(this.stats.totalTimeSaved / 1000)
    };
  }

  /**
     * üìà RELAT√ìRIO DE PERFORMANCE
     */
  generatePerformanceReport() {
    const stats = this.getStats();
        
    console.log('\nüìà ========== RELAT√ìRIO DE PERFORMANCE - CACHE ==========');
    console.log(`üéØ Taxa de hit: ${stats.hitRate}%`);
    console.log(`üí≠ Uso de mem√≥ria: ${stats.memoryUsage}/${stats.maxMemorySize}`);
    console.log(`üíæ Hits em disco: ${stats.diskHits}`);
    console.log(`üìä Total de opera√ß√µes: ${stats.hits + stats.misses}`);
    console.log(`‚ö° Tempo total economizado: ${stats.totalTimeSavedSeconds}s`);
    console.log(`üìâ Tempo m√©dio economizado: ${stats.avgTimeSavedPerOperation}ms/opera√ß√£o`);
    console.log(`üóëÔ∏è Evic√ß√µes: ${stats.evictions}`);
        
    // Efici√™ncia do cache
    const efficiency = stats.hitRate;
    let efficiencyLevel = 'Baixa';
    if (efficiency > 80) efficiencyLevel = 'Excelente';
    else if (efficiency > 60) efficiencyLevel = 'Boa';
    else if (efficiency > 40) efficiencyLevel = 'Regular';
        
    console.log(`\nüèÜ EFICI√äNCIA DO CACHE: ${efficiencyLevel} (${stats.hitRate}%)`);
        
    return stats;
  }

  /**
     * üóÇÔ∏è OBTER CAMINHO DO CACHE EM DISCO
     */
  getDiskCachePath(cacheKey) {
    return path.join(this.config.disk.directory, `${cacheKey}.json`);
  }

  /**
     * üèóÔ∏è INICIALIZAR CACHE EM DISCO
     */
  async initializeDiskCache() {
    if (!this.config.disk.enabled) return;
        
    try {
      await fs.mkdir(this.config.disk.directory, { recursive: true });
    } catch (error) {
      console.error('‚ùå [CACHE] Erro ao criar diret√≥rio de cache:', error.message);
      this.config.disk.enabled = false;
    }
  }

  /**
     * üìù ATUALIZAR METADADOS
     */
  updateMetadata(cacheKey, metadata) {
    this.metadata.set(cacheKey, metadata);
  }

  /**
     * üßπ LIMPAR CACHE ESPEC√çFICO
     */
  async invalidate(key) {
    const cacheKey = this.generateCacheKey(key);
        
    // Remover da mem√≥ria
    this.memoryCache.delete(cacheKey);
    this.metadata.delete(cacheKey);
        
    // Remover do disco
    if (this.config.disk.enabled) {
      try {
        const filePath = this.getDiskCachePath(cacheKey);
        await fs.unlink(filePath);
      } catch (error) {
        // Ignorar se arquivo n√£o existe
      }
    }
        
    console.log(`üßπ [CACHE] Invalidado: ${key}`);
  }

  /**
     * üóëÔ∏è LIMPAR TODO O CACHE
     */
  async clear() {
    // Limpar mem√≥ria
    this.memoryCache.clear();
    this.metadata.clear();
        
    // Limpar disco
    if (this.config.disk.enabled) {
      try {
        const files = await fs.readdir(this.config.disk.directory);
        await Promise.all(
          files.filter(f => f.endsWith('.json'))
            .map(f => fs.unlink(path.join(this.config.disk.directory, f)))
        );
      } catch (error) {
        console.error('‚ùå [CACHE] Erro ao limpar disco:', error.message);
      }
    }
        
    console.log('üóëÔ∏è [CACHE] Cache completamente limpo');
  }

  /**
     * üîÑ RESETAR ESTAT√çSTICAS
     */
  resetStats() {
    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      evictions: 0,
      diskHits: 0,
      diskMisses: 0,
      totalTimeSaved: 0,
      operationsSaved: 0
    };
    console.log('üîÑ [CACHE] Estat√≠sticas resetadas');
  }
}

module.exports = IntelligentCacheSystem;